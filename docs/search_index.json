[["index.html", "Estadística con R Preámbulo", " Estadística con R Facultad de Psicología, Universidad de Talca 2022-12-01 Preámbulo Este curso se basa en Statistics without tears de Derek Rowntree y Discovering statistics using R de Andy Field, Jeremy Miles y Zoë Field. Este curso también utiliza material del libro &quot;Discovering statistics using R&quot;. Este material es accesible aquí. Este curso asume que no sabes nada de estadística. Sin embargo, si asume que sabes aritmética básica y fracciones. La base de datos que vamos a utilizar se encuentra aquí. ¡Que disfrutes el curso! "],["introducción-a-la-estadística.html", "Capítulo 1 Introducción a la estadística 1.1 ¿Qué es la estadística? 1.2 ¿Variables? 1.3 Diseños experimentales 1.4 ¿Qué medimos? 1.5 Un prueba estadística 1.6 ¿Que diseño usaré? 1.7 Una historia fantástica 1.8 ¿Randomizar?", " Capítulo 1 Introducción a la estadística En este capítulo introductorio vamos a ir paso a paso. Vamos a hacernos de una visión general de la estadística y vamos a entender por qué tenemos que hacer &quot;inferencias&quot;, es decir, sacar conclusiones de algunos datos que recolectamos para saber algo del mundo alredor nuestro (de una población en particular). 1.1 ¿Qué es la estadística? Revisa este video (9') y trata de responder: ¿Qué es la estadística descriptiva y la estadística inferencial? ¿Qué es una población y una muestra? ¿Qué son los &quot;parámetros&quot;&quot; y los &quot;estadísticos&quot;? ¿Por qué necesitamos obtener una muestra para nuestros experimentos? ¿Por qué necesitamos las probabilidades para realizar análisis estadísticos? 1.2 ¿Variables? Revisa este video (9') y trata de responder: ¿Qué tipos de variables existen? ¿Que significa definir variables y operacionalizar? ¿Que es una variable independiente? ¿Que es una variable dependiente? ¿Cómo se construye una hipótesis? 1.3 Diseños experimentales Revisa este video (4') y trata de responder: ¿Qué tipos de diseño experimental existen? ¿Cuáles son las ventajas y desventajas de cada uno de ellos? 1.4 ¿Qué medimos? Revisa este video (7') y trata de responder: ¿Qué aspectos son importantes a la hora de diseñar un experimento? ¿Qué es la validez de una medición? ¿Qué es la replicabilidad de una medición? ¿Qué es un factor confundente? 1.5 Un prueba estadística Revisa este video (14') y trata de responder: ¿Por qué es tan importante evaluar como cambian (o varían) las variables? ¿Qué hace un prueba estadística (en términos de los cambios que experimenta una variable)? ¿Qué es la variación sistemática (VS)? ¿Qué es la variación no sistemática (VNS)? Sí una manipulación experimental produce un efecto genuino como será la razón VS/VNS? 1.6 ¿Que diseño usaré? Revisa este video (4') y trata de responder: ¿Cuál es la diferencia entre un diseño intra-sujetos y un diseño entre-sujetos? ¿Cuál es la relación entre un diseño experimental y su análisis estadístico asociado? 1.7 Una historia fantástica Revisa este video (9') y trata de responder: ¿Quién fué Roland Fisher? ¿Dé dónde viene el 5% (o p = 0.05) que usamos en estadística? 1.8 ¿Randomizar? Revisa este video (6') y trata de responder: ¿Para que se usa la randomización? ¿Qué son los efectos de práctica y de aburrimiento en un diseño intra-sujetos? ¿Cómo podemos confeccionar un buen diseño entre-sujetos? "],["conceptos-estadísticos.html", "Capítulo 2 Conceptos estadísticos 2.1 La significancia 2.2 Colas 2.3 Errores estadísticos 2.4 Tamaño &amp; poder 2.5 Planificar mi estudio", " Capítulo 2 Conceptos estadísticos 2.1 La significancia Revisa este video (9') y trata de responder: ¿Qué me dice y qué no me dice el valor de p? ¿Cómo se interpreta un resultado estadístico nulo? 2.2 Colas Revisa este video (11') y trata de responder: ¿Cuál es la diferencia entre una hipótesis de una cola y una hipótesis de dos colas? ¿Por qué los criterios de significancia son más altos para una hipótesis de una cola que para una hipótesis de dos colas? 2.3 Errores estadísticos Revisa este video (9') y trata de responder: ¿Qué es un error de tipo I? ¿Qué es un error de tipo II? ¿Por qué hay un balance entre el error de tipo I y II? ¿Qué es mas perjudicial para un estudio? ¿Un error de tipo I o II? 2.4 Tamaño &amp; poder Revisa este video (8') y trata de responder: ¿Qué es el tamaño del efecto? ¿Cómo se contabiliza el tamaño del efecto? ¿Qué es el poder estadístico? ¿Cómo definimos el tamaño de la muestra que necesitamos para un experimento? 2.5 Planificar mi estudio Revisa este video (9') y trata de responder: ¿Cómo planificar mejor mi estudio? ¿Por qué debo planificar mi análisis ANTES de recolectar los datos? "],["programación.html", "Capítulo 3 Programación 3.1 ¿Que significa programar? 3.2 La shell (consola) versus el script 3.3 Intro a la programación 3.4 Empezando a programar 3.5 Trabajando con data frames 3.6 Importando datos 3.7 Seleccionando datos 3.8 Transformado datos en formato long a wide y viceversa 3.9 Exportando datos 3.10 En la práctica", " Capítulo 3 Programación En este capítulo te voy a mostrar las primeras ideas para que puedas programar en R. 3.1 ¿Que significa programar? Revisa este video (8') y trata de responder: ¿Qué habilidades permite desarrollar el conocimiento de programación? ¿Qué es un algoritmo? ¿Qué es un lenguaje de programación? 3.2 La shell (consola) versus el script Revisa este video (6') y trata de responder: ¿Cuál es la diferencia entre un compilador y un intérprete? ¿Cuál es la diferencia entre usar la shell (consola) y usar un script? ¿Qué es el CRAN? 3.3 Intro a la programación Revisa este video (16') para comenzar a trabajar en RStudio. Mas abajo repetiré el mismo contenido para que vayas viendo como usar el material que viene mas abajo. La idea es que vayas trabajando tus propios scripts ordenadamente en tu computador. 3.4 Empezando a programar En lo que sigue te recomiendo que crees un script (lo nombres &quot;Curso_1&quot; o algo así) y que vayas escribiendo o copiando lo que vamos viendo más abajo. En general, luego de una línea de código aparece el resultado precedido por ##. En un script es esencial incluir comentarios. De esta manera puedes acordarte (y otros puedes entender) que está haciendo tu código. Para escribir un comentario debes anteponer un #. En el inicio de un script es un buen hábito poner una fecha y tus iniciales. Por ejemplo: # JLUF 16/08/2022 También es buena idea que agregues una breve descripción de lo que hace tu código. # JLUF 16/08/2022 # Estadística descriptiva R tiene algunas funciones integradas. Por ejemplo: el promedio (mean) y la desviación estándar (sd). Para probar estas funciones podemos aplicarlas a una series de números (o vector). Para crear un vector podemos usar la c y un paréntesis. Lo que hacemos con la c es concatenar números. # JLUF 16/08/2022 # Estadística descriptiva # Promedio entre 2 y 3 mean(c(2,3)) ## [1] 2.5 # Deviación estándar entre 2 y 3 sd(c(2,3)) ## [1] 0.7071068 Comúnmente para hacer un cálculo de manera óptima usamos algo que se llama asignación. Es decir, creamos una variable y le asignamos un valor. Por ejemplo, definimos que a equivale a 2 y b equivale a 3. Luego podemos usar solamente esas variables para hacer cálculos. Para asignar ponemos una flecha: &quot;&lt;-&quot; a &lt;- 2 b &lt;- 3 mean(c(a,b)) ## [1] 2.5 También podemos crear variables que contengan texto. Por ejemplo, podemos crear una lista con los integrantes de Metallica. metallica &lt;- c(&quot;Lars&quot;, &quot;James&quot;, &quot;Jason&quot;, &quot;Kirk&quot;) metallica ## [1] &quot;Lars&quot; &quot;James&quot; &quot;Jason&quot; &quot;Kirk&quot; Este es un vector de carácteres. Además, puedes usar las funciones str() y class() para averiguar la naturaleza de estas variables. class(metallica) ## [1] &quot;character&quot; str(metallica) ## chr [1:4] &quot;Lars&quot; &quot;James&quot; &quot;Jason&quot; &quot;Kirk&quot; Para inspeccionar cada elemento de esta variable puedes usar el paréntesis cuadrado. Esto se llama indexar. Por ejemplo, para ver el primer elemento puedes hacer lo siguiente: metallica[1] ## [1] &quot;Lars&quot; O podrías ver desde el primero al segundo. metallica[1:2] ## [1] &quot;Lars&quot; &quot;James&quot; O podrías ver desde el segundo al tercero. metallica[2:3] ## [1] &quot;James&quot; &quot;Jason&quot; Si te das cuenta que tu lista tiene un elemento incorrecto lo puedes eliminar. Para ello debes crear una nueva variable a partir de metallica pero dentro del paréntesis cuadrado usamos una fórmula lógica. La fórmula nos permite seleccionar ciertos elementos. Por ejemplo, si queremos todos los elementos de la variable metallica excepto el elemento Jason (de ahí viene la parte !=) podemos hacer lo siguente: new_metallica &lt;- metallica[metallica != &quot;Jason&quot;] new_metallica ## [1] &quot;Lars&quot; &quot;James&quot; &quot;Kirk&quot; También puedes eliminar dos elementos indicandole a R que quieres eliminar los elementos del 2 al 3: metallica_duo &lt;- metallica[-c(2,3)] metallica_duo ## [1] &quot;Lars&quot; &quot;Kirk&quot; Lo que podríamos hacer enseguida es agregar un nuevo elemento. Para hacer esto concatenamos, usado la c, un variable con otra variable. Por ejemplo, para concatenar new_metallica con &quot;Rob&quot; hacemos lo siguiente: last_metallica &lt;- c(new_metallica, &quot;Rob&quot;) last_metallica ## [1] &quot;Lars&quot; &quot;James&quot; &quot;Kirk&quot; &quot;Rob&quot; Incluso podríamos elegir dónde agregar a Rob. Por ejemplo, lo podemos agregar al final. last_metallica_2 &lt;- c(&quot;Rob&quot;, new_metallica) last_metallica_2 ## [1] &quot;Rob&quot; &quot;Lars&quot; &quot;James&quot; &quot;Kirk&quot; O lo podemos agregar en la penúltima posición: last_metallica_3 &lt;- c(new_metallica[1:2], &quot;Rob&quot;, new_metallica[3]) last_metallica_3 ## [1] &quot;Lars&quot; &quot;James&quot; &quot;Rob&quot; &quot;Kirk&quot; Ejercicio: Crea una variable que represente a tu banda favorita. 3.5 Trabajando con data frames Podemos crear variables de distintos tipos (lista de palabras o listas de números): metallicaNames &lt;- c(&quot;Lars&quot;, &quot;James&quot;, &quot;Kirk&quot;, &quot;Rob&quot;) metallicaNames ## [1] &quot;Lars&quot; &quot;James&quot; &quot;Kirk&quot; &quot;Rob&quot; metallicaAges &lt;- c(47, 47, 48, 46) metallicaAges ## [1] 47 47 48 46 metallicaColor &lt;- c(&quot;Blue&quot;, &quot;Red&quot;, &quot;Yellow&quot;, &quot;Green&quot;) metallicaColor ## [1] &quot;Blue&quot; &quot;Red&quot; &quot;Yellow&quot; &quot;Green&quot; Pero más importante que eso es que podemos reunir estas variables en una estructura mas compleja. Esta estructura se llama data frame. Un data frame puede acomodar distintos tipos de datos y los pone en distintas &quot;cajas&quot;. Para crear un data frame usamos la función data.frame metallicaDataFrame &lt;- data.frame(metallicaNames, metallicaAges, metallicaColor) metallicaDataFrame ## metallicaNames metallicaAges metallicaColor ## 1 Lars 47 Blue ## 2 James 47 Red ## 3 Kirk 48 Yellow ## 4 Rob 46 Green Fijate que al crear el data frame el nombre de la variable se vuelve el encabezado de esos datos en el dataframe. Si queremos podemos cambiarle el nombre a estos encabezados. Podemos hacer esto usando la función colnames. colnames(metallicaDataFrame) &lt;- c(&quot;name&quot;, &quot;age&quot;, &quot;color&quot;) metallicaDataFrame ## name age color ## 1 Lars 47 Blue ## 2 James 47 Red ## 3 Kirk 48 Yellow ## 4 Rob 46 Green O mejor aún puedes definirlo al momento de crear la data frame: metallicaDataFrame &lt;- data.frame(Name = metallicaNames, Age = metallicaAges, Color = metallicaColor) metallicaDataFrame ## Name Age Color ## 1 Lars 47 Blue ## 2 James 47 Red ## 3 Kirk 48 Yellow ## 4 Rob 46 Green Mira también la estructura de este data frame. Verás que hay 4 observacions y 3 variables. Dos de estas listas son carácteres. str(metallicaDataFrame) ## &#39;data.frame&#39;: 4 obs. of 3 variables: ## $ Name : chr &quot;Lars&quot; &quot;James&quot; &quot;Kirk&quot; &quot;Rob&quot; ## $ Age : num 47 47 48 46 ## $ Color: chr &quot;Blue&quot; &quot;Red&quot; &quot;Yellow&quot; &quot;Green&quot; Para mirar cada una de las lista puedes usar el símbolo $ metallicaDataFrame$Name ## [1] &quot;Lars&quot; &quot;James&quot; &quot;Kirk&quot; &quot;Rob&quot; metallicaDataFrame$Age ## [1] 47 47 48 46 metallicaDataFrame$Color ## [1] &quot;Blue&quot; &quot;Red&quot; &quot;Yellow&quot; &quot;Green&quot; Además, podemos eliminar una de estas listas si no nos interesa. metallicaDataFrame$Color &lt;- NULL metallicaDataFrame ## Name Age ## 1 Lars 47 ## 2 James 47 ## 3 Kirk 48 ## 4 Rob 46 Mas importante aún es el hecho que podemos hacer cálculos matemáticos de forma masiva. Primero, agreguemos una columna nueva: metallicaDataFrame$ChildAge &lt;- c(12, 12, 4, 6) metallicaDataFrame ## Name Age ChildAge ## 1 Lars 47 12 ## 2 James 47 12 ## 3 Kirk 48 4 ## 4 Rob 46 6 Luego, podemos calcular la diferencia entre estas dos columnas y la asignamos a una nueva columna: metallicaDataFrame$FatherhoodAge &lt;- metallicaDataFrame$Age - metallicaDataFrame$ChildAge metallicaDataFrame ## Name Age ChildAge FatherhoodAge ## 1 Lars 47 12 35 ## 2 James 47 12 35 ## 3 Kirk 48 4 44 ## 4 Rob 46 6 40 Podemos agregar mas datos a partir de otra variable. Y para crear variables podemos concatenar pedazos de datos. Por ejemplo, podríamos querer crear un set de datos de 15 valores que representen 3 condiciones experimentales. Cada condición experimental podría estar repetida 5 veces. Si queremos repetir la condición 1 tres veces hacemos: rep(1,5) ## [1] 1 1 1 1 1 El primer parámetro dentro de la función rep es el número que quieres repetir. El segundo parámetro define las veces que se va a definir ese número. Luego, podemos concatenar repeticiones de distintos números. vector1 &lt;- c(rep(1,5), rep(2,5), rep(3,5)) vector1 ## [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 Y eso lo podemos agregar luego en una data frame. Veamos un ejemplo mas elaborado. Vamos a crear un base de datos sobre el nombre, la fecha de nacimiento y el trabajo de distintas personas. Para que R identifique los números como fechas usamos la función as.Date(por defecto el formato es yyyy-mm-dd). name &lt;- c(&quot;Ben&quot;, &quot;Martin&quot;,&quot;Andy&quot;,&quot;Paul&quot;, &quot;Graham&quot;,&quot;Carina&quot;,&quot;Karina&quot;,&quot;Doug&quot;,&quot;Mark&quot;, &quot;Zoe&quot;) name ## [1] &quot;Ben&quot; &quot;Martin&quot; &quot;Andy&quot; &quot;Paul&quot; &quot;Graham&quot; &quot;Carina&quot; &quot;Karina&quot; &quot;Doug&quot; &quot;Mark&quot; &quot;Zoe&quot; birth_date &lt;- as.Date(c(&quot;1977-07-03&quot;, &quot;1969-05-24&quot;, &quot;1973-06-21&quot;, &quot;1970-07-16&quot;, &quot;1949-10-10&quot;, &quot;1983-11-05&quot;, &quot;1987-10-08&quot;, &quot;1989-09-16&quot;, &quot;1973-05-20&quot;, &quot;1984-11-12&quot;)) birth_date ## [1] &quot;1977-07-03&quot; &quot;1969-05-24&quot; &quot;1973-06-21&quot; &quot;1970-07-16&quot; &quot;1949-10-10&quot; &quot;1983-11-05&quot; &quot;1987-10-08&quot; &quot;1989-09-16&quot; ## [9] &quot;1973-05-20&quot; &quot;1984-11-12&quot; job &lt;- c(rep(1, 5), rep(2, 5)) # que es el equivalente a: job &lt;- c(1,1,1,1,1,2,2,2,2,2) job ## [1] 1 1 1 1 1 2 2 2 2 2 La variable job es categórica. El número 1 indica que es un profesor y el 2 indica que es un estudiante. Para R son sólo números. Para decirle a R que es una variable categórica (o en el lenguaje de R un factor) tenemos que indicarselo usando la función factor. Además, podemos crear etiquetas o nombres que nos hagan mas sentido a nosotros. En este caso este factor tiene dos niveles: Lecturer y Student. job &lt;- factor(job, levels = c(1:2), labels = c(&quot;Lecturer&quot;, &quot;Student&quot;)) job ## [1] Lecturer Lecturer Lecturer Lecturer Lecturer Student Student Student Student Student ## Levels: Lecturer Student Luego, el paso final es poner todo junto: dataframe1 &lt;- data.frame(name, birth_date, job) dataframe1 ## name birth_date job ## 1 Ben 1977-07-03 Lecturer ## 2 Martin 1969-05-24 Lecturer ## 3 Andy 1973-06-21 Lecturer ## 4 Paul 1970-07-16 Lecturer ## 5 Graham 1949-10-10 Lecturer ## 6 Carina 1983-11-05 Student ## 7 Karina 1987-10-08 Student ## 8 Doug 1989-09-16 Student ## 9 Mark 1973-05-20 Student ## 10 Zoe 1984-11-12 Student Ejercicio: Crea una data frame con los integrantes de tu grupo familiar o de tu curso. En tu data frame agrega el nombre, apellido y la edad. 3.6 Importando datos La mayoría del tiempo vas a importar más que crear datos. Para ello cuando trabajes en R debes decirle en que carpeta de tu computador están esos archivos. Es decir, debes definir tu directorio de trabajo con la función setwd Por ejemplo, para mí sería algo así: setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Stats_UTalca/database_2020_DocPsychol&quot;) La función getwd() (sin nada entre paréntesis) te permite sabes cual es tu directorio actual. getwd() ## [1] &quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot; Para importar datos puedes usar distintas funciones. Por ejemplo, para importar datos de tipo .txt debemos usar la función read.delim setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) dat &lt;- read.delim(file = &quot;data/facebook_friends_1.txt&quot;) dat ## X108 ## 1 103 ## 2 252 ## 3 121 ## 4 93 ## 5 57 ## 6 40 ## 7 53 ## 8 22 ## 9 116 ## 10 98 Si ejecutas este comando en tu computador y lo comparas con los datos originales te darás cuenta que hay un error. Cuando importate tus datos a R perdiste el 108. Esto occurre porque por defecto esta función asume que tus datos tienen un encabezado (el &quot;header&quot;). Es decir, el parámetro llamado &quot;header&quot; esta fijado en &quot;TRUE&quot;&quot;, que significa que la función espera un encabezado. Para corregir esto debes explícitamente decirle a R que no hay header, así: setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) dat &lt;- read.delim(file = &quot;data/facebook_friends_1.txt&quot;, header = FALSE) dat ## V1 ## 1 108 ## 2 103 ## 3 252 ## 4 121 ## 5 93 ## 6 57 ## 7 40 ## 8 53 ## 9 22 ## 10 116 ## 11 98 Fijate ahora que R le asigna un nombre a tu columna (V1). Es buena práctica ponerme un nombre a tu columna que haga sentido. Por ejemplo, podemos llamarla &quot;friends&quot;: colnames(dat) &lt;- c(&quot;friends&quot;) dat ## friends ## 1 108 ## 2 103 ## 3 252 ## 4 121 ## 5 93 ## 6 57 ## 7 40 ## 8 53 ## 9 22 ## 10 116 ## 11 98 Cuando tus datos ya tienen un encabezado te ahorras estos problemas. Fjate que para importar este otro archivo no necesitas definir que el header a FALSE. setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) dat &lt;- read.delim(file = &quot;data/facebook_friends_2.txt&quot;) dat ## AMIGOS ## 1 108 ## 2 103 ## 3 252 ## 4 121 ## 5 93 ## 6 57 ## 7 40 ## 8 53 ## 9 22 ## 10 116 ## 11 98 Típicamente vas a importar que has registrado en archivos de tipo Excel (.xls o .xlsx). El archivo Excel se puede transformar en un archivo de tipo csv. Este arhivo csv se importa de la siguiente manera: setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) dat2 &lt;- read.csv(&quot;data/facebook_friends_1.csv&quot;, header = FALSE) dat2 ## V1 ## 1 108 ## 2 103 ## 3 252 ## 4 121 ## 5 93 ## 6 57 ## 7 40 ## 8 53 ## 9 22 ## 10 116 ## 11 98 Para importar archivos siempre asegurate que has seteado bien tu directorio de trabajo y que los archivos están ahí. Ejercicio: Trata de importar algún archivo csv a tu sesión de R. 3.7 Seleccionando datos Una vez que tienes datos en tu espacio de trabajo en R la idea es que puedas manipular esos datos. Uno de los aspectos fundamentales de esta manipulación es la selección de datos. Primero, importemos alguna base de datos. setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) lecturerDat &lt;- read.csv(&quot;data/lecturer_data.csv&quot;) lecturerDat ## name birth_date job friends alcohol income neurotic ## 1 Ben 07/03/1977 1 5 10 20000 10 ## 2 Martin 5/24/1969 1 2 15 40000 17 ## 3 Andy 6/21/1973 1 0 20 35000 14 ## 4 Paul 7/16/1970 1 4 5 22000 13 ## 5 Graham 10/10/1949 1 1 30 50000 21 ## 6 Carina 11/05/1983 2 10 25 5000 7 ## 7 Karina 10/08/1987 2 12 20 100 13 ## 8 Doug 1/23/1989 2 15 16 3000 9 ## 9 Mark 5/20/1973 2 12 17 10000 14 ## 10 Zoe 11/12/1984 2 17 18 10 13 Antes de proceder vamos a transformar la variable &quot;job&quot; a factor, y vamos a crear rótulos que nos hagan mas sentido. Esto lo podemos hacer porque sabemos que el rótulo 1 corresponde a &quot;Lecturer&quot; y el rótulo 2 corresponde a &quot;Student&quot;. lecturerDat$job &lt;- factor(lecturerDat$job, levels = c(1:2), labels = c(&quot;Lecturer&quot;, &quot;Student&quot;)) lecturerDat ## name birth_date job friends alcohol income neurotic ## 1 Ben 07/03/1977 Lecturer 5 10 20000 10 ## 2 Martin 5/24/1969 Lecturer 2 15 40000 17 ## 3 Andy 6/21/1973 Lecturer 0 20 35000 14 ## 4 Paul 7/16/1970 Lecturer 4 5 22000 13 ## 5 Graham 10/10/1949 Lecturer 1 30 50000 21 ## 6 Carina 11/05/1983 Student 10 25 5000 7 ## 7 Karina 10/08/1987 Student 12 20 100 13 ## 8 Doug 1/23/1989 Student 15 16 3000 9 ## 9 Mark 5/20/1973 Student 12 17 10000 14 ## 10 Zoe 11/12/1984 Student 17 18 10 13 Ahora, imagina que quieres seleccionar datos de aquellos participantes que eran sólo &quot;Lecturer&quot;. Podemos seleccionar esos datos y asignarlos a una nueva variable, así: onlyLecturer &lt;- lecturerDat[lecturerDat$job == &quot;Lecturer&quot;,] onlyLecturer ## name birth_date job friends alcohol income neurotic ## 1 Ben 07/03/1977 Lecturer 5 10 20000 10 ## 2 Martin 5/24/1969 Lecturer 2 15 40000 17 ## 3 Andy 6/21/1973 Lecturer 0 20 35000 14 ## 4 Paul 7/16/1970 Lecturer 4 5 22000 13 ## 5 Graham 10/10/1949 Lecturer 1 30 50000 21 Ahora, imagina que quieres seleccionar datos de aquellos participantes cuyo nivel de alcohol es menor o igual a 15: lightAlcoholics &lt;- lecturerDat[lecturerDat$alcohol &lt;= 15,] lightAlcoholics ## name birth_date job friends alcohol income neurotic ## 1 Ben 07/03/1977 Lecturer 5 10 20000 10 ## 2 Martin 5/24/1969 Lecturer 2 15 40000 17 ## 4 Paul 7/16/1970 Lecturer 4 5 22000 13 Lo que acabas de hacer es seleccionar sólo algunas filas. Algo que también puedes realizar es seleccionar sólo algunas columnas. Por ejemplo, podrías seleccionar sólo aquellos datos relacionados con las columnas &quot;friends&quot;, &quot;alcohol&quot; y &quot;neurotic&quot;. Para ello puedes hacer: lecturerPersonality &lt;- lecturerDat[, c(&quot;friends&quot;, &quot;alcohol&quot;, &quot;neurotic&quot;)] lecturerPersonality ## friends alcohol neurotic ## 1 5 10 10 ## 2 2 15 17 ## 3 0 20 14 ## 4 4 5 13 ## 5 1 30 21 ## 6 10 25 7 ## 7 12 20 13 ## 8 15 16 9 ## 9 12 17 14 ## 10 17 18 13 Incluso puedes combinar la selección de filas y de columnas. Por ejemplo podrías seleccionar las columnas &quot;friends&quot;, &quot;alcohol&quot; y &quot;neurotic&quot; de aquello participantes cuyo nivel de alcohol es menor o igual a 15: lightAlcoholicsPerso &lt;- lecturerDat[lecturerDat$alcohol &lt;= 15, c(&quot;friends&quot;, &quot;alcohol&quot;, &quot;neurotic&quot;)] lightAlcoholicsPerso ## friends alcohol neurotic ## 1 5 10 10 ## 2 2 15 17 ## 4 4 5 13 3.8 Transformado datos en formato long a wide y viceversa Otro aspecto muy importante que debes entender es como transformar de un formato a otro en R. En R hay dos formatos típicos. Cuando hay múltiples mediciones de un mismo sujeto, por ejemplo, a lo largo del tiempo o cuando se realizan distintas mediciones los datos a menudo se anotan en formato wide. En un formato wide la data frame contiene valores que no se repiten en la primera columna. En un formato long la data frame contiene valores que se repiten en la primera columna. Por ejemplo, importemos un set de datos que está en formato wide: setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) satisfactionData &lt;- read.csv(&quot;data/Honeymoon_Period.csv&quot;) head(satisfactionData) ## Person Satisfaction_Base Satisfaction_6_Months Satisfaction_12_Months Satisfaction_18_Months Gender ## 1 1 6 6 5 2 0 ## 2 2 7 7 8 4 1 ## 3 3 4 6 2 2 1 ## 4 4 6 9 4 1 0 ## 5 5 6 7 6 6 0 ## 6 6 5 10 4 2 1 Con head miramos sólo los primeras 6 filas de la base de datos. En esta data frame están los niveles de satisfacción con la pareja al momento de casarse, y luego de 6, 12 y 18 meses. Además está el género del entrevistado. Esta data frame la podemos a transformar a un formato long usando la función stack. Esta función la usamos de la siguiente manera: newDataFrame &lt;- stack(oldDataFrame, select = c(variable_list)) En nuestro ejemplo podemos hacerlo así: satisfactionStacked &lt;- stack(satisfactionData, select = c(&quot;Satisfaction_Base&quot;, &quot;Satisfaction_6_Months&quot;, &quot;Satisfaction_12_Months&quot;, &quot;Satisfaction_18_Months&quot;)) colnames(satisfactionStacked) &lt;- c(&quot;Values&quot;, &quot;SatisfType&quot;) # cambiamos los encabezados head(satisfactionStacked) ## Values SatisfType ## 1 6 Satisfaction_Base ## 2 7 Satisfaction_Base ## 3 4 Satisfaction_Base ## 4 6 Satisfaction_Base ## 5 6 Satisfaction_Base ## 6 5 Satisfaction_Base En esta data frame se puede ver que los valores de satisfacción se ubican en una columna y la condición se ubica en otra columna. El problema con esta transformación es que perdemos la información de género y el número de la persona. Más adelante veremos una manera de hacer esta transformación sin perder esta información. Esta data frame la podemos reconvertir en formato wide con la función unstack. Esta función la usamos de la siguiente manera: newDataFrame &lt;- unstack(oldDataFrame, scores ~ columns) O simplemente: newDataFrame &lt;- unstack(oldDataFrame) En nuestro ejemplo podemos hacerlo así: satisfactionUnstacked &lt;- unstack(satisfactionStacked) head(satisfactionUnstacked) ## Satisfaction_Base Satisfaction_6_Months Satisfaction_12_Months Satisfaction_18_Months ## 1 6 6 5 2 ## 2 7 7 8 4 ## 3 4 6 2 2 ## 4 6 9 4 1 ## 5 6 7 6 6 ## 6 5 10 4 2 satisfactionUnstacked2 &lt;- unstack(satisfactionStacked, Values ~ SatisfType) head(satisfactionUnstacked2) ## Satisfaction_Base Satisfaction_6_Months Satisfaction_12_Months Satisfaction_18_Months ## 1 6 6 5 2 ## 2 7 7 8 4 ## 3 4 6 2 2 ## 4 6 9 4 1 ## 5 6 7 6 6 ## 6 5 10 4 2 Otra manera de transformar datos a formato long es usando la función melt. Para ello necesitamos cargar la librería reshape. Esta función la usamos de la siguiente manera: newDataFrame &lt;- melt(oldDataFrame, id = c(constant_variables), measured = c(variables_that_change_across_columns)) En nuestro ejemplo podemos hacerlo así: library(reshape) restructuredData &lt;- melt(satisfactionData, id = c(&quot;Person&quot;, &quot;Gender&quot;), measured = c(&quot;Satisfaction_Base&quot;, &quot;Satisfaction_6_Months&quot;, &quot;Satisfaction_12_Months&quot;, &quot;Satisfaction_18_Months&quot;)) colnames(restructuredData)[3:4] &lt;- c(&quot;SatisfType&quot;, &quot;Values&quot;) # cambiamos los encabezados head(restructuredData) ## Person Gender SatisfType Values ## 1 1 0 Satisfaction_Base 6 ## 2 2 1 Satisfaction_Base 7 ## 3 3 1 Satisfaction_Base 4 ## 4 4 0 Satisfaction_Base 6 ## 5 5 0 Satisfaction_Base 6 ## 6 6 1 Satisfaction_Base 5 Bonus.También podemos aprovechar de reordenar los datos. Para ello usamos la función order. reorder2 &lt;- restructuredData[order(restructuredData$Person),] head(reorder2) ## Person Gender SatisfType Values ## 1 1 0 Satisfaction_Base 6 ## 116 1 0 Satisfaction_6_Months 6 ## 231 1 0 Satisfaction_12_Months 5 ## 346 1 0 Satisfaction_18_Months 2 ## 2 2 1 Satisfaction_Base 7 ## 117 2 1 Satisfaction_6_Months 7 En esta data frame se puede ver que los valores de satisfacción se ubican en una columna y la condición se ubica en otra columna. La ventaja de melt es que conserva la información de género y el número de la persona. Por último, esta data frame la podemos reconvertir en formato wide con la función cast. Esta función la usamos de la siguiente manera: newData &lt;- cast(longData, variables_coded_within_a_single_column ~ variables_coded_across_many_columns, value = &quot;outcome_variable&quot;) En nuestro ejemplo podemos hacerlo así: wideData &lt;- cast(restructuredData, Person + Gender ~ SatisfType, value = &quot;Values&quot;) head(wideData) ## Person Gender Satisfaction_Base Satisfaction_6_Months Satisfaction_12_Months Satisfaction_18_Months ## 1 1 0 6 6 5 2 ## 2 2 1 7 7 8 4 ## 3 3 1 4 6 2 2 ## 4 4 0 6 9 4 1 ## 5 5 0 6 7 6 6 ## 6 6 1 5 10 4 2 3.9 Exportando datos Finalmente podrías querer exportar estos datos seleccionados. Para ello puede crear archivos de tipo txt o csv aplicado algunas funciones. Los archivos se crearán en tu actual directorio (para saber cual es puedes hacer getwd()) write.table(lightAlcoholics, &quot;datoExportado.txt&quot;, sep=&quot;\\t&quot;) write.csv(lightAlcoholics, &quot;datoExportado.csv&quot;) 3.10 En la práctica Veamos que información podemos sacar de datos que importamos. setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) library(ggplot2) Primero importemos datos. dat &lt;- read.csv(&quot;data/latidos_cardiacos.csv&quot;, header = TRUE) # load data Luego calculemos algunos estadísticos. mean(dat$latidos) ## [1] 79.08 sd(dat$latidos) ## [1] 7.674075 Y hagamos algunos gráficos (más de esto luego). h1 &lt;- ggplot(dat, aes(latidos)) h1 + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. h1 &lt;- ggplot(dat, aes(&quot;&quot;, latidos)) h1 + geom_boxplot() Veámos otros datos. dat &lt;- read.csv(&quot;data/demografia_salud.csv&quot;, header = TRUE) # load data table(dat$Sexo) ## ## Hombre Mujer ## 24 16 table(dat$Estado.Civil) ## ## Casado Divorciado Soltero Viudo ## 24 6 6 4 mean(dat$Número.de.hijos) ## [1] 1.475 sd(dat$Número.de.hijos) ## [1] 1.154423 min(dat$Peso) ## [1] 58 max(dat$Peso) ## [1] 89 dat$Altura &lt;- as.numeric(gsub(&quot;,&quot;, &quot;.&quot;, dat$Altura)) aggregate(Altura ~ Sexo, data = dat, mean) ## Sexo Altura ## 1 Hombre 1.703333 ## 2 Mujer 1.646875 aggregate(Altura ~ Sexo, data = dat, sd) ## Sexo Altura ## 1 Hombre 0.07653738 ## 2 Mujer 0.06279265 dat$PA.Min &lt;- dat$Pr.Arter.Máx dat$PA.Max &lt;- dat$Pr.Arter.Mín aggregate(PA.Max ~ Estado.Civil, data = dat, mean) ## Estado.Civil PA.Max ## 1 Casado 141.7917 ## 2 Divorciado 137.1667 ## 3 Soltero 142.0000 ## 4 Viudo 144.2500 aggregate(PA.Max ~ Estado.Civil, data = dat, sd) ## Estado.Civil PA.Max ## 1 Casado 9.002315 ## 2 Divorciado 10.553041 ## 3 Soltero 6.000000 ## 4 Viudo 7.675719 "],["gráficos.html", "Capítulo 4 Gráficos 4.1 ¿Cómo graficamos en R? 4.2 Gráfico de puntos 4.3 Gráfico de dispersión 4.4 Histograma 4.5 Boxplot 4.6 Gráfico de barras 4.7 Gráfico de líneas (1 factor) 4.8 Gráfico de líneas (2 factores)", " Capítulo 4 Gráficos En este capítulo vamos a revisar algunos aspectos básicos para hacer gráficos en R. 4.1 ¿Cómo graficamos en R? Revisa este video (16') y trata de responder: ¿Cómo se hace un buen gráfico? ¿Qué significa que se usen capas para hacer gráficos en R? 4.2 Gráfico de puntos Primero seteamos nuestro directorio de trabajo. Para graficar cargamos la librería ggplot2 (que tiene que haber sido previamente instalada). Al mismo tiempo se cargan otras librerías que nos serviran. Si no tienes estas librerías debes instalarlas. Finalmente importamos un set de datos y lo miramos. setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) library(ggplot2) library(reshape) library(plyr) library(Rmisc) facebookData &lt;- read.delim(&quot;data/FacebookNarcissism.dat&quot;, header = TRUE) # load data head(facebookData) ## id NPQC_R_Total Rating_Type Rating ## 1 1 31 Attractive 2 ## 2 1 31 Fashionable 2 ## 3 1 31 Glamourous 2 ## 4 1 31 Cool 2 ## 5 2 37 Attractive 2 ## 6 2 37 Fashionable 2 En este estudio se recolectaron una serie de datos de los participantes relacionados con rasgos de personalidad y niveles de narcisimo. id indica la identidad del participante. NPQC_R_Total indica la puntuación total en el cuestionario de narcisismo. Rating_Type una característica de personalidad y Rating indica la calificación (en una escala de 1 a 5) de esa característica de personalidad. Ubcaremos NPQC_R_Total en el eje X y Rating en el eje Y. Acuérdate que para crear gráficos con ggplot debes crear un objeto dónde se encuentra la estructura base. Para visualizar el gráfico se debe invocar el objeto y al mismo debes agregar las distintas capas que constituyen el gráfico. Por ejemplo, un capa de puntos. graph &lt;- ggplot(facebookData, aes(NPQC_R_Total, Rating)) graph + geom_point() Además, puedes ir agregando otras capas. Por ejemplo, el título. graph &lt;- ggplot(facebookData, aes(NPQC_R_Total, Rating)) graph + geom_point() + labs(title = &quot;Figura 1&quot;) Podemos cambiar los puntos por triángulos, usando el parámetro shape. graph + geom_point(shape = 17) O podemos cambiar el tamaño de los puntos, usando el parámetro size. graph + geom_point(size = 6) También podemos colorear los puntos en función de los diferentes puntajes. Para ello debemos definir un color dentro del parámetro aes. graph + geom_point(aes(colour = Rating_Type)) Por último, podríamos tener un problema de &quot;sobreploteo&quot;, es decir, dado que hay un limitado número de respuestas que la personas podrían dar para valores equivalentes no se van a observar puntos diferentes. Para evitar esto podemos cambiar el parámetro position para agregar un retraso (o &quot;jitter). graph + geom_point(aes(colour = Rating_Type), position = &quot;jitter&quot;) 4.3 Gráfico de dispersión En un gráfico de dispersión se dibuja la puntuación de una una variable frente a la puntuación de otra variable. En este ejemplo un psicólogo estaba interesado en entender los efectos que produce el estrés sobre el rendimiento en este examen. Se diseñó y se validó un cuestionario para evaluar el estado de ansiedad relacionado con los exámenes (llamado Cuestionario de Ansiedad ante los Exámenes, o EAQ). Esta escala produce un puntaje de ansiedad desd 1 a 100. La ansiedad se midió antes de un examen, y la calificación de cada estudiante en el examen se utilizó para medir el rendimiento del examen. Primero, importemos los datos. No es necesario que carguemos la librerías si ya están cargadas. examData &lt;- read.delim(&quot;data/ExamAnxiety.dat&quot;, header = TRUE) head(examData) ## Code Revise Exam Anxiety Gender ## 1 1 4 40 86.298 Male ## 2 2 11 65 88.716 Female ## 3 3 27 80 70.178 Male ## 4 4 53 80 61.312 Male ## 5 5 4 40 89.522 Male ## 6 6 22 70 60.506 Female Fíjate que en la data frame hay 5 variables: Code: Un número que indica la identidad del participante. Revise: El total de horas que los participantes dedicaron para estudiar. Exam: La nota en el examen que tuvo el participante (como porcentaje). Anxiety: La puntuación en la esclala de ansiedad. Gender: El género (masculino o femenino). Primero, vamos a crear la estructura base del gráfico. scatter &lt;- ggplot(examData, aes(Anxiety, Exam)) Fíjate que la estuctura base definimos que vamos a gráficar la relación entre la ansiedad (Anxiety) y las notas (Exam). Luego, podemos ir agregando las capas. Por ejemplo, los puntos que relfejan cada participante y los títulos en los ejes. scatter + geom_point() + labs(x = &quot;Exam Anxiety&quot;, y = &quot;Exam Performance %&quot;) En general, en los gráficos de dispersión agregamos una línea de tendencia que resume la relación entre las variables. La sombra asociada a la línea representa un intervalo de confianza (CI) al 95%. scatter + geom_point() + geom_smooth() + labs(x = &quot;Exam Anxiety&quot;, y = &quot;Exam Performance %&quot;) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Pero, en general, se agrega una linea recta. Para ello usamos la función geom_smooth. scatter + geom_point() + geom_smooth(method = &quot;lm&quot;, colour = &quot;Red&quot;) + labs(x = &quot;Exam Anxiety&quot;, y = &quot;Exam Performance %&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Opcionalmente se puede omitir la sombra. scatter + geom_point() + geom_smooth(method = &quot;lm&quot;, colour = &quot;Green&quot;, se = FALSE) + labs(x = &quot;Exam Anxiety&quot;, y = &quot;Exam Performance %&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Además, podemos cambiar la transparencia de la línea, cambiando el parámetro alpha. Y también podamos cambiar el relleno (&quot;fill&quot;) de la sombra. scatter + geom_point() + geom_smooth(method = &quot;lm&quot;, alpha = 0.1, fill = &quot;Blue&quot;) + labs(x = &quot;Exam Anxiety&quot;, y = &quot;Exam Performance %&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; ¿Qué pasa si queremos hacer gráficos de dispersión en función de más de una variable? Por ejemplo, podríamos querer ver las distintas relaciones entre ansiedad y puntajes en la prueba, en función del género (hombres versus mujeres). Para ello debemos re-definir la estructura base del gráfico, y debemmos agregar la variable género dentro del parámetro aes. scatter &lt;- ggplot(examData, aes(Anxiety, Exam, colour = Gender)) Luego podemos hacer un nuevo gráfico. scatter + geom_point() + geom_smooth(method = &quot;lm&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; También podemos dibujar las líneas de acuerdo al género (y además podemos hacer las líneas transparentes). Para ello debemos definir un parámetro aes dentro de la función geom_smooth. scatter + geom_point() + geom_smooth(method = &quot;lm&quot;, alpha = 0.1, aes(fill = Gender)) + labs(x = &quot;Exam Anxiety&quot;, y = &quot;Exam Performance %&quot;, colour = &quot;Gender&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; 4.4 Histograma Un histograma es una representación gráfica de una variable en forma de barras, donde la superficie de cada barra es proporcional a la frecuencia de los valores representados. En este ejemplo un biólogo estaba preocupado por los posibles efectos en la salud de los festivales de música. Un año fue al Download Music Festival y midió los niveles de higiene de 810 asistentes al concierto durante los tres días del festival. Dado que era difícil rastrear a todas las personas en esta base de datos faltaban algunos datos en los días 2 y 3. La higiene se midió utilizando una técnica estandarizada que da como resultado una puntuación que oscila entre 0 (hueles como un cadáver) y 4 (hueles a rosas dulces en un día fresco de primavera). Primero, importemos los datos. No es necesario que carguemos la librerías si ya están cargadas. festivalData &lt;- read.delim(&quot;data/DownloadFestival.dat&quot;, header = TRUE) head(festivalData) ## ticknumb gender day1 day2 day3 ## 1 2111 Male 2.64 1.35 1.61 ## 2 2229 Female 0.97 1.41 0.29 ## 3 2338 Male 0.84 NA NA ## 4 2384 Female 3.03 NA NA ## 5 2401 Female 0.88 0.08 NA ## 6 2405 Male 0.85 NA NA Primero, vamos a crear la estructura base del gráfico. festivalHistogram &lt;- ggplot(festivalData, aes(day1)) Y luego hacemos el gráfico. festivalHistogram + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Por defecto se realizan los agrupamientos (o &quot;bins) en grupos de 30 puntos. Hay varias cosas que podemos observar en este gráfico. Se observa inmediatamente que hay una valor mucho más alto que el resto de los valores. Podría ser un potencial outlier. También nos damos cuenta que podríamos usar una mejor definición de bins. Para ello podemos modificar el parámetro bindwith. Además, le podemos agregar unos títulos a los ejes. festivalHistogram + geom_histogram(binwidth = 0.4) + labs(x = &quot;Hygiene (Day 1 of Festival)&quot;, y = &quot;Frequency&quot;) Para lidiar con el outlier tenemos 2 opciones. Podemos eliminarlo de archivo original. O sea importamos un nuevo archivo. # import data festivalDataAlt &lt;- read.delim(&quot;data/DownloadFestival_NoOutlier.dat&quot;, header = TRUE) # define base graph festivalHistogramAlt &lt;- ggplot(festivalDataAlt, aes(day1)) # add layers festivalHistogramAlt + geom_histogram(binwidth = 0.6) + labs(x = &quot;Hygiene (Day 1 of Festival)&quot;, y = &quot;Frequency&quot;) Mejor aún. Como una segunda opción podemos ubicar el outlier en la data frame. Para ello usamos la función order para order los datos de menor a mayor. Luego usamos la función tail para ver los últimos puntos de los datos. # import data festivalData &lt;- festivalData[order(festivalData$day1),] tail(festivalData) ## ticknumb gender day1 day2 day3 ## 774 4564 Female 3.38 3.44 3.41 ## 300 3371 Female 3.41 NA NA ## 657 4264 Male 3.44 NA NA ## 303 3374 Male 3.58 3.35 NA ## 574 4016 Female 3.69 NA NA ## 611 4158 Female 20.02 2.44 NA Aquí nos fijamos que hay un valor exageradamente alto. Se escribe 20.02, y es probable que sea un error de registro. Lo que podemos hacer es eliminar manualmente el valor o modificarlo a 2.02. festivalDataGood &lt;- festivalData festivalDataGood$day1[810] &lt;- 2.02 Y podemos re-hacer el gráfico. festivalHistogramGood &lt;- ggplot(festivalDataGood, aes(day1)) festivalHistogramGood + geom_histogram(binwidth = 0.4) + labs(x = &quot;Hygiene (Day 1 of Festival)&quot;, y = &quot;Frequency&quot;) 4.5 Boxplot En un boxplot (o gráfico de cajas y bigotes) visualizamos la distribución y la asimetría en los datos mostrando los promedios y cuartiles (o percentiles) del set de datos. Vamos a usar los mismos que usamos antes. Veamos los datos originales, pero esta veámoslo en función del género. Debemos re-hacer la estructura base. festivalBoxplot &lt;- ggplot(festivalData, aes(gender, day1)) festivalBoxplot + geom_boxplot() + labs(x = &quot;Gender&quot;, y = &quot;Hygiene (Day 1 of Festival)&quot;) En este tipo de gráfico también se puede visualizar el outlier. Ya habíamos lidiado con este problema transformando el valor del oulier. Podemos hacer un boxplot con la nueva data frame. # define base graph festivalBoxplotAlt &lt;- ggplot(festivalDataAlt, aes(gender, day1)) # add layers festivalBoxplotAlt + geom_boxplot() + labs(x = &quot;Gender&quot;, y = &quot;Hygiene (Day 1 of Festival)&quot;) Por último, podemos hacer los boxplots para el día 2. festivalBoxplot &lt;- ggplot(festivalData, aes(gender, day2)) festivalBoxplot + geom_boxplot() + labs(x = &quot;Gender&quot;, y = &quot;Hygiene (Day 2 of Festival)&quot;) ## Warning: Removed 546 rows containing non-finite values (stat_boxplot). Y para el día 3. festivalBoxplot &lt;- ggplot(festivalData, aes(gender, day3)) festivalBoxplot + geom_boxplot() + labs(x = &quot;Gender&quot;, y = &quot;Hygiene (Day 3 of Festival)&quot;) ## Warning: Removed 687 rows containing non-finite values (stat_boxplot). 4.6 Gráfico de barras El gráfico de barras es el más común de las visualizaciones. En este ejemplo un el director de una compañía cinematográfica estuvo interesado en saber si realmente existía el efecto llamado &quot;chick flick&quot;, es decir, el hecho que hay películas que atraen más a las mujeres que a los hombres. Para investigar esta pregunta reclutó a 20 hombres y 20 mujeres y les mostró a la mitad de cada grupo una película que se suponía era para chicas (&quot;El diario de Bridget Jones), y a la otra mitad de cada grupo una película que no caía en esta categoría de película (Memento). En todos los casos midió la excitación fisiológica (la conductancia de la piel) como indicador de cuánto disfrutaron la película los participantes. Como siempre, primero importemos los datos. No es necesario que carguemos la librerías si ya están cargadas. chickFlick &lt;- read.csv(&quot;data/chick_flick.csv&quot;, header = TRUE) head(chickFlick) ## genero pelicula estado.de.alerta ## 1 Hombre Bridget Jones&#39; Diary 22 ## 2 Hombre Bridget Jones&#39; Diary 13 ## 3 Hombre Bridget Jones&#39; Diary 16 ## 4 Hombre Bridget Jones&#39; Diary 10 ## 5 Hombre Bridget Jones&#39; Diary 18 ## 6 Hombre Bridget Jones&#39; Diary 24 # cambiemos los nombres colnames(chickFlick) &lt;- c(&quot;gender&quot;, &quot;film&quot;, &quot;arousal&quot;) head(chickFlick) ## gender film arousal ## 1 Hombre Bridget Jones&#39; Diary 22 ## 2 Hombre Bridget Jones&#39; Diary 13 ## 3 Hombre Bridget Jones&#39; Diary 16 ## 4 Hombre Bridget Jones&#39; Diary 10 ## 5 Hombre Bridget Jones&#39; Diary 18 ## 6 Hombre Bridget Jones&#39; Diary 24 Fíjate que hay variables: gender: El género del participante. film: La película que estaba vió el participante. arousal: El nivel de excitación del participante. Antes de crear la estructura base del gráfico vamos a hacer algunos cálculos. Para ello nos vamos a valer de algunas funciones estadísticas. La función summarySE nos permite calcular varias métricas estadísticas (N, promedio, SD, SE, CI) en función de otra variable. En este caso vamos a calcular el arousal promedio en función del tipo de film. Está función necesita de la librería Rmisc que ya está cargada. dataSumm &lt;- summarySE(chickFlick, measurevar=&quot;arousal&quot;, groupvars = c(&quot;film&quot;)) dataSumm ## film N arousal sd se ci ## 1 Bridget Jones&#39; Diary 20 14.80 5.727128 1.280625 2.680379 ## 2 Memento 20 25.25 7.129442 1.594192 3.336682 Y luego hacemos el gráfico. # usamos la tabla que recién creamos y graficamos el promedio del arousal (eje Y) en fución del film (eje X) ggplot(dataSumm, aes(x=film, y=arousal)) + # agregamos las barras dónde estan los promedios # dodge permite crear un pequeño desfase entre la posición dónde se ubican los promedios geom_bar(position = position_dodge(width = 0.9), stat=&quot;identity&quot;, color=&quot;black&quot;, fill=&quot;green&quot;, show.legend=FALSE) + # agregamos las barras de error # dodge permite crear un pequeño desfase entre la posición dónde se ubican los promedios # podemos modificar el ancho de las barras de error con &quot;width&quot; # podemos definir los mínimos y máximos de las barras de error, tipicamente el error se muestra hacia arriba geom_errorbar(position = position_dodge(width=0.9), width=0.25, aes(ymin=arousal, ymax=arousal+se)) + # creamos un fondo blanco para que se vea mejor # se elimina la rejilla que aparece en el fondo theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) + # podemos cambiar los límites y las separaciones del eje Y scale_y_continuous(limits = c(0,30), breaks = seq(0, 30, 5)) + # también podemos renombrar la etiqueta de los ejes ylab(&quot;Arousal&quot;) + xlab(&quot;Film&quot;) Para entender mejor el rol de estos parámetros en la configuración del gráfico, cámbialos. Además, podríamos querer visualizar los valores de excitación no sólo en función de las películas, sino que también en función del género. Usamos la función summarySE para calcular el arousal promedio en función del tipo de film y del género. dataSumm &lt;- summarySE(chickFlick, measurevar=&quot;arousal&quot;, groupvars = c(&quot;film&quot;, &quot;gender&quot;)) dataSumm ## film gender N arousal sd se ci ## 1 Bridget Jones&#39; Diary Hombre 10 17.2 4.779586 1.511438 3.419110 ## 2 Bridget Jones&#39; Diary Mujer 10 12.4 5.796551 1.833030 4.146603 ## 3 Memento Hombre 10 25.8 7.238784 2.289105 5.178314 ## 4 Memento Mujer 10 24.7 7.364328 2.328805 5.268123 Luego graficamos. # Aquí debemos definir como ver el género dento del parámetro aes. ggplot(dataSumm, aes(x=film, y=arousal, fill=gender)) + geom_bar(position = position_dodge(width = 0.9), stat=&quot;identity&quot;, color=&quot;black&quot;) + geom_errorbar(position = position_dodge(width=0.9), width=0.25, aes(ymin=arousal, ymax=arousal+se)) + # podemos cambiar los colores de relleno scale_fill_manual(values=c(&quot;white&quot;, &quot;black&quot;)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) + scale_y_continuous(limits = c(0,30), breaks = seq(0, 30, 5)) + ylab(&quot;Arousal&quot;) + xlab(&quot;Film&quot;) 4.7 Gráfico de líneas (1 factor) El gráfico de líneas es también muy común para visualizar datos. En este ejemplo se reclutaron 15 personas con hipo y durante un ataque de hipo se administraron tres procedimientos para detener el hipo (recibir un susto, ingerir un poco de azúcar y respirar en una bolsa) en orden aleatorio y a intervalos de 5 minutos. Además, se tomó una línea de base de cuántos hipo tuvieron por minuto. Durante al aplicación de los procedimientos para detener el hipo se contaron el numero de hipos por minuto. Como siempre, primero importemos los datos. hiccupsData &lt;- read.csv(&quot;data/hipo.csv&quot;, header = TRUE) head(hiccupsData) ## ID Linea.base Susto Azucar Bolsa ## 1 1 15 9 7 2 ## 2 2 13 18 7 4 ## 3 3 9 17 5 4 ## 4 4 7 15 10 5 ## 5 5 11 18 7 4 ## 6 6 14 8 10 3 colnames(hiccupsData)[2] &lt;- &quot;Base&quot; head(hiccupsData) ## ID Base Susto Azucar Bolsa ## 1 1 15 9 7 2 ## 2 2 13 18 7 4 ## 3 3 9 17 5 4 ## 4 4 7 15 10 5 ## 5 5 11 18 7 4 ## 6 6 14 8 10 3 Hay cuatro tratamientos: Base: el número de hipos sin ningún tratamiento. Susto: número de hipos al recibir un susto. Azucar: número de hipo al ingerir un poco de azúcar. Bolsa: número de hipos al respirar en una bolsa. Cada fila en la base de datos representa a una persona diferente. Esto refleja un diseño de medidas repetidas. Cada columna representa una condición de tratamiento diferente. Y cada persona que se somete a cada uno de los tratamientos. Antes de graficar con ggplot debemos cambiar el formato de la base de datos. El ID no nos interesa y nos podemos deshacer de él. hiccupsData$ID &lt;- NULL hiccups &lt;- stack(hiccupsData) head(hiccups) ## values ind ## 1 15 Base ## 2 13 Base ## 3 9 Base ## 4 7 Base ## 5 11 Base ## 6 14 Base colnames(hiccups) &lt;- c(&quot;Hipos&quot;,&quot;Tratamiento&quot;) head(hiccups) ## Hipos Tratamiento ## 1 15 Base ## 2 13 Base ## 3 9 Base ## 4 7 Base ## 5 11 Base ## 6 14 Base Para graficar una variable categórica en ggplot debemos transformarla a factor. A veces R automáticamente identifica esta variables como categóricas. Además, podemos cambiar el orden en que aparecen las condiciones en el gráfico, # Si una variable es categórica se puede ver hacia el final de los datos que existen niveles. # En este caso la variable &quot;Tratamieto&quot; tiene 4 niveles. hiccups$Tratamiento ## [1] Base Base Base Base Base Base Base Base Base Base Base Base Base Base Base ## [16] Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto ## [31] Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar ## [46] Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa ## Levels: Base Susto Azucar Bolsa hiccups$Tratamiento2 &lt;- factor(hiccups$Tratamiento, levels(hiccups$Tratamiento)[c(1, 4, 2, 3)]) hiccups$Tratamiento2 ## [1] Base Base Base Base Base Base Base Base Base Base Base Base Base Base Base ## [16] Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto Susto ## [31] Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar Azucar ## [46] Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa Bolsa ## Levels: Base Bolsa Susto Azucar Usamos la función summarySE para calcular el número de hipos promedio en función del tratamiento. dataSumm &lt;- summarySE(hiccups, measurevar=&quot;Hipos&quot;, groupvars=&quot;Tratamiento&quot;) dataSumm ## Tratamiento N Hipos sd se ci ## 1 Base 15 13.133333 4.8383390 1.2492537 2.6793828 ## 2 Susto 15 12.800000 5.4142669 1.3979577 2.9983211 ## 3 Azucar 15 8.733333 2.3441924 0.6052679 1.2981705 ## 4 Bolsa 15 3.533333 0.8338094 0.2152887 0.4617482 Luego graficamos. # Para hacer un gráfico de línea debemos setear en el aes una estética de grupo igual a 1 # Esto nos permite agrupar puntos promedio dentro de un grupo en una línea ggplot(dataSumm, aes(x=Tratamiento, y=Hipos, group=1)) + # agregamos las barras de error geom_errorbar(width=0.1, aes(ymin=Hipos-se, ymax=Hipos+se)) + # agregamos las líneas que unen los puntos geom_line(colour = &quot;Red&quot;, linetype = &quot;dashed&quot;) + # agregamos los puntos que indican los promedios geom_point() + ylab(&quot;Número de hipos&quot;) + # coord_cartesian(ylim = c(830, 900)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) 4.8 Gráfico de líneas (2 factores) Imagina que llevamos a cabo un experimento en el que a un grupo de 25 niños se les pidió enviar mensajes de texto vía sus teléfonos móviles durante un período de seis meses. A un segundo grupo de 25 niños se le prohibió enviar mensajes de texto por el mismo período. A estos dos grupos se les aplicó una pueba gramatical para medir el efecto de enviar mensajes de texto sobre su habilidades gramaticales. La primera variable independiente fue el uso de mensajes de texto (uso de mensajes de texto versus controles) y la segunda variable independiente fue el tiempo (línea de base versus después de 6 meses). Importemos los datos. textData &lt;- read.csv(&quot;data/usuarios_de_whatsapp.csv&quot;, header = TRUE) head(textData) ## Grupo Linea.base X6.meses ## 1 Usarios de Whatsapp 52 32 ## 2 Usarios de Whatsapp 68 48 ## 3 Usarios de Whatsapp 85 62 ## 4 Usarios de Whatsapp 47 16 ## 5 Usarios de Whatsapp 73 63 ## 6 Usarios de Whatsapp 57 53 # missing something! colnames(textData) &lt;- c(&quot;Group&quot;, &quot;Baseline&quot;, &quot;Six_months&quot;) head(textData) ## Group Baseline Six_months ## 1 Usarios de Whatsapp 52 32 ## 2 Usarios de Whatsapp 68 48 ## 3 Usarios de Whatsapp 85 62 ## 4 Usarios de Whatsapp 47 16 ## 5 Usarios de Whatsapp 73 63 ## 6 Usarios de Whatsapp 57 53 Hay 3 variables: Grupo: especifica si estaban en el grupo de mensajes de texto o en el grupo de control. Baseline: puntajes de gramática en la línea de base. Six_months: puntajes de gramática después de 6 meses. Cada fila en la base de datos representa a una persona diferente. Estos datos están nuevamente en el formato incorrecto para ggplot. En lugar del formato wide actual necesitamos los datos en formato long. Entonces necesitamos reestructurar los datos a una nueva data frame. textMessages &lt;- melt(textData, id = c(&quot;Group&quot;), measured = c(&quot;Baseline&quot;, &quot;Six_months&quot;)) head(textMessages) ## Group variable value ## 1 Usarios de Whatsapp Baseline 52 ## 2 Usarios de Whatsapp Baseline 68 ## 3 Usarios de Whatsapp Baseline 85 ## 4 Usarios de Whatsapp Baseline 47 ## 5 Usarios de Whatsapp Baseline 73 ## 6 Usarios de Whatsapp Baseline 57 colnames(textMessages)[c(2,3)] &lt;- c(&quot;Time&quot;, &quot;Grammar_Score&quot;) head(textMessages) ## Group Time Grammar_Score ## 1 Usarios de Whatsapp Baseline 52 ## 2 Usarios de Whatsapp Baseline 68 ## 3 Usarios de Whatsapp Baseline 85 ## 4 Usarios de Whatsapp Baseline 47 ## 5 Usarios de Whatsapp Baseline 73 ## 6 Usarios de Whatsapp Baseline 57 A esta altura podríamos querer cambiar los nombres de las condiciones. También podemos hacer eso. head(textMessages) ## Group Time Grammar_Score ## 1 Usarios de Whatsapp Baseline 52 ## 2 Usarios de Whatsapp Baseline 68 ## 3 Usarios de Whatsapp Baseline 85 ## 4 Usarios de Whatsapp Baseline 47 ## 5 Usarios de Whatsapp Baseline 73 ## 6 Usarios de Whatsapp Baseline 57 textMessages$Time &lt;- factor(textMessages$Time, labels = c(&quot;Baseline&quot;, &quot;6 Months&quot;)) tail(textMessages) ## Group Time Grammar_Score ## 95 Controles 6 Months 78 ## 96 Controles 6 Months 62 ## 97 Controles 6 Months 71 ## 98 Controles 6 Months 55 ## 99 Controles 6 Months 46 ## 100 Controles 6 Months 79 En esta base de datos tenemos las siguientes variables: Grupo: especifica si estaban en el grupo de mensajes de texto o en el grupo de control. Time: especifica si la puntuación se relaciona con la línea de base o después de 6 meses. Grammar_Score: especifica las puntuaciones de gramática. Enseguida, Usamos la función summarySE para calcular los puntajes de grámatica promedio en función de la condición y el tiempo. dataSumm &lt;- summarySE(textMessages, measurevar=&quot;Grammar_Score&quot;, groupvars=c(&quot;Group&quot;, &quot;Time&quot;)) dataSumm ## Group Time N Grammar_Score sd se ci ## 1 Controles Baseline 25 65.60 10.835897 2.167179 4.472839 ## 2 Controles 6 Months 25 61.84 9.410455 1.882091 3.884445 ## 3 Usarios de Whatsapp Baseline 25 64.84 10.679732 2.135946 4.408377 ## 4 Usarios de Whatsapp 6 Months 25 52.96 16.331156 3.266231 6.741170 Luego graficamos. # En este caso debemos decirle a R que coloree las líneas en función de las condiciones experimentales. ggplot(dataSumm, aes(x=Time, y=Grammar_Score, colour=Group)) + # agregamos las barras de error geom_errorbar(aes(ymin=Grammar_Score-se, ymax=Grammar_Score+se), width=.1, position=position_dodge(0.1)) + # agregamos las líneas que unen los puntos geom_line(position=position_dodge(0.1), aes(group=Group), show.legend=FALSE) + # agregamos los puntos que indican los promedios geom_point(position=position_dodge(0.1), aes(group=Group), show.legend=FALSE) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) + ylab(&quot;Mean Grammar Score&quot;) + scale_colour_manual(values=c(&quot;red&quot;, &quot;blue&quot;)) + coord_cartesian(ylim = c(45, 70)) "],["caracterizar-datos.html", "Capítulo 5 Caracterizar datos 5.1 Visualizar los datos 5.2 La curva normal 5.3 La curva normal en la práctica (1) 5.4 La curva normal en la práctica (2) 5.5 De la muestra a la población 5.6 La muestra en la vida real 5.7 Los intervalos de confianza (1) 5.8 Los intervalos de confianza (2)", " Capítulo 5 Caracterizar datos En este capítulo vamos a revisar algunos elementos relacionados con la estadística inferencial. Para entender estas ideas primero vamos a hablar sobre como caracterizamos y visualizamos nuestros datos. 5.1 Visualizar los datos Revisa este video (17') y trata de responder: ¿Por qué es importante graficar los datos? ¿Cómo se calcula la desviación estándar? ¿Qué es la suma de cuadrados (o suma de los errores al cuadrado)? 5.2 La curva normal Revisa este video (10') y trata de responder: ¿Cómo se puede visualizar la &quot;forma&quot; de los datos? ¿Qué características tiene la curva normal? ¿Cómo estimamos cuantas observaciones caen entre dos valores para una set de datos? ¿Qué porcentaje de los datos esta entre -1 SD y 1 SD? 5.3 La curva normal en la práctica (1) Revisa este video (8') y trata de responder: ¿Cuantos vehículos anduvieron a exceso de velocidad? PAUSA el video para responder ¿Qué porcentaje de los datos esta entre -2 SD y 2 SD? ¿Qué porcentaje de los datos esta entre -2.5 SD y 2.5 SD? 5.4 La curva normal en la práctica (2) Revisa este video (9') y trata de responder: ¿Entre cuantas SD tenemos prácticamente todos los puntos de un set de datos? ¿Entre Linda y Bill quien saco mejor puntaje dentro de su cohorte? PAUSA el video para responder 5.5 De la muestra a la población Revisa este video (17') y trata de responder: ¿Qué significa generalizar nuestros hallazgos? ¿Qué son los parámetros? ¿Qué son los estadísticos? ¿Qué es la variación de la muestra (o sampling variation)? ¿Qué representa el promedio de los promedios de las muestras? 5.6 La muestra en la vida real Revisa este video (10') y trata de responder: ¿Qué pasa en la vida con respecto a la distribución de los promedios de las muestras? ¿Qué es el error estándar y como se calcula? 5.7 Los intervalos de confianza (1) Revisa este video (13') y trata de responder: ¿Cómo se calcula el SE? ¿Cómo se estima el promedio de la población? ¿Qué son los intervalos de confianza? 5.8 Los intervalos de confianza (2) Revisa este video (6') y trata de responder: ¿Qué significa que cálculemos un promedio con un intervalo de confianza al 68%? ¿Qué significa que cálculemos un promedio con un intervalo de confianza al 95%? "],["comparar-dos-grupos-t-test.html", "Capítulo 6 Comparar dos grupos (t-test) 6.1 ¿Cómo comparamos datos de dos grupos? 6.2 La distribución normal para dos grupos 6.3 La prueba de hipótesis 6.4 El t-test como un modelo líneal general 6.5 El t-test con R", " Capítulo 6 Comparar dos grupos (t-test) En este capítulo vamos a revisar el típico t-test. 6.1 ¿Cómo comparamos datos de dos grupos? Revisa este video (10') y trata de responder: ¿Cómo se sabe si dos muestras viene de una misma población o de poblaciones diferentes? ¿Cómo podemos usar los intervalos de confianzar para estimar las diferencias entre dos muestras? 6.2 La distribución normal para dos grupos Revisa este video (9') y trata de responder: ¿Para que nos sirve la distribución normal para compara dos muestras? 6.3 La prueba de hipótesis Revisa este video (12') y trata de responder: ¿Cuál es la hipótesis nula cuando comparamos dos muestras? 6.4 El t-test como un modelo líneal general Revisa este video (15') y trata de responder: ¿Cómo se refleja un t-test en un modelo lineal general (GLM)? ¿Qué representa el intercepto de la ecuación de un GLM para una variable outcome cuando se comparan dos grupos? ¿Qué representa la pendiente de la ecuación de un GLM para una variable outcome cuando se comparan dos grupos? 6.5 El t-test con R Ahora vamos a hacer el análisis. Primero seteamos nuestro directorio de trabajo y cargamos las librerías que necesitemos (si no las tienes instaladas debes instalarlas). Luego importamos el set de datos y le damos una mirada. setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) library(ggplot2) library(Hmisc) library(Rmisc) library(effsize) library(pastecs) library(reshape2) library(car) library(effsize) spiderLong &lt;- read.csv(&quot;data/ansiedad_por_arañas_indep.csv&quot;, header = TRUE) # load data spiderLong$Condicion &lt;- factor(spiderLong$Condicion) head(spiderLong) ## Sujeto Condicion Conductancia ## 1 1 imagen 30 ## 2 2 imagen 35 ## 3 3 imagen 45 ## 4 4 imagen 40 ## 5 5 imagen 50 ## 6 6 imagen 35 Luego, mirar los datos siempre es bueno graficar. # Podemos usar esta función para calcular los estadísticos a través de los participantes. datac &lt;- summarySE(spiderLong, measurevar=&quot;Conductancia&quot;, groupvars = &quot;Condicion&quot;) # Luego hacemos el gráfico ggplot(datac, aes(x = Condicion, y = Conductancia)) + geom_bar(position = position_dodge(width = 0.9), stat = &quot;identity&quot;, color = &quot;black&quot;, fill = &quot;White&quot;, show.legend=FALSE) + geom_errorbar(position=position_dodge(.9), width=.25, aes(ymin = Conductancia, ymax = Conductancia+se)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) + scale_y_continuous(limits = c(0,55), breaks = seq(0, 55, 10)) + ylab(&quot;Conductancia&quot;) Recordando lo que acabamos de aprender vamos a comparar los promedios por cada grupo con la información que resulta de aplicar una regresión lineal a estos datos. Primero describamos los datos. lapply(by(spiderLong$Conductancia, spiderLong$Condicion, stat.desc, basic = FALSE, norm = TRUE), round, 2) ## $imagen ## median mean SE.mean CI.mean.0.95 var std.dev coef.var skewness ## 40.00 40.00 2.68 5.90 86.36 9.29 0.23 0.00 ## skew.2SE kurtosis kurt.2SE normtest.W normtest.p ## 0.00 -1.39 -0.57 0.97 0.85 ## ## $real ## median mean SE.mean CI.mean.0.95 var std.dev coef.var skewness ## 50.00 47.00 3.18 7.01 121.64 11.03 0.23 -0.01 ## skew.2SE kurtosis kurt.2SE normtest.W normtest.p ## 0.00 -1.46 -0.59 0.95 0.62 La función by permite calcular los estadísticos. La función round redondea los valores a dos décimas. Y la función lapply permite aplicar la función round de forma másiva. Ahora, vamos a realiza una regresión lineal. Lo que queremos es predecir los valores de conductancia en función de los grupos (o condiciones) que tenemos. Para realizar la regresión usamos la función lm Luego de hacer la regresión lineal podemos revisar su contenido con la función summary. Recuerda mirar los coeficientes. ¿Qué ves? m1 &lt;- lm(Conductancia ~ Condicion, data=spiderLong) summary(m1) ## ## Call: ## lm(formula = Conductancia ~ Condicion, data = spiderLong) ## ## Residuals: ## Min 1Q Median 3Q Max ## -17.0 -8.5 1.5 8.0 18.0 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 40.000 2.944 13.587 3.53e-12 *** ## Condicionreal 7.000 4.163 1.681 0.107 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 10.2 on 22 degrees of freedom ## Multiple R-squared: 0.1139, Adjusted R-squared: 0.07359 ## F-statistic: 2.827 on 1 and 22 DF, p-value: 0.1068 Finalmente, podemos hacer el t-test. Pero, antes de hacerlo debemos verificar si existen problemas de homgeneidad de varianza. Podemos hacerlo con la función leveneTest leveneTest(spiderLong$Conductancia, spiderLong$Condicion) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 1 0.2991 0.59 ## 22 Luego podemos hacer el análisis estadístico, aplicando la función t.test. De la siguiente forma: newModel &lt;- t.test(outcome ~ predictor, data=df, var.equal = TRUE/FALSE, paired=TRUE/FALSE). Ya que no tenemos problemas de homogeneidad de varianzar seteamos var.equal a FALSE. t_test1 &lt;- t.test(Conductancia ~ Condicion, data=spiderLong, var.equal = TRUE, paired = FALSE) t_test1 ## ## Two Sample t-test ## ## data: Conductancia by Condicion ## t = -1.6813, df = 22, p-value = 0.1068 ## alternative hypothesis: true difference in means between group imagen and group real is not equal to 0 ## 95 percent confidence interval: ## -15.634222 1.634222 ## sample estimates: ## mean in group imagen mean in group real ## 40 47 Para terminar siempre es bueno calcular el tamaño del efecto. t &lt;- t_test1$statistic[[1]] df &lt;- t_test1$parameter[[1]] r &lt;- sqrt(t**2/(t**2+df)) r ## [1] 0.3374392 Ahora, imaginemos que en realidad nuestro diseño experimental era intra-sujetos. Vamos a usar exactamente los mismos datos que antes pero asumiendo un diseño intra-sujetos. Y asumiremos que estos datos viendo en un formato wide. spiderWide &lt;- read.csv(&quot;data/ansiedad_por_arañas_dep.csv&quot;, header = TRUE) # load data head (spiderWide) ## Sujeto imagen real ## 1 1 30 40 ## 2 2 35 35 ## 3 3 45 50 ## 4 4 40 55 ## 5 5 50 65 ## 6 6 35 55 Para realizar el gráfico para un diseño intra-sujetos tenemos que hacer algunos ajustes. spiderWideOri &lt;- spiderWide spiderWide$pMean &lt;- (spiderWide$imagen + spiderWide$real)/2 grandMean &lt;- mean(c(spiderWide$imagen, spiderWide$real)) spiderWide$adj &lt;- grandMean - spiderWide$pMean spiderWide$imagen_adj &lt;- spiderWide$imagen + spiderWide$adj spiderWide$real_adj &lt;- spiderWide$real + spiderWide$adj spiderWide$Mean2 &lt;- mean(spiderWide$imagen_adj + spiderWide$real_adj)/2 spiderWideSelec &lt;- spiderWide[, -c(2:5)] spiderWideSelec &lt;- spiderWideSelec[, -4] names(spiderWideSelec) &lt;- c(&quot;Sujeto&quot;, &quot;imagen&quot;, &quot;real&quot;) Los datos ajustados los transformamos a formato Long. adjustedData &lt;- melt(spiderWideSelec, id = c(&quot;Sujeto&quot;), measured = c(&quot;imagen&quot;, &quot;real&quot;)) names(adjustedData) &lt;- c(&quot;Sujeto&quot;, &quot;Condicion&quot;, &quot;Conductancia&quot;) Luego procedemos como antes. # Podemos usar esta función para calcular los estadísticos para un diseño intra-sujetos. datac2 &lt;- summarySEwithin(adjustedData, measurevar=&quot;Conductancia&quot;, withinvars=&quot;Condicion&quot;, idvar=&quot;Sujeto&quot;) ggplot(datac2, aes(x=Condicion, y=Conductancia)) + geom_bar(position = position_dodge(width = 0.9), stat=&quot;identity&quot;, color=&quot;black&quot;, fill=&quot;White&quot;, show.legend=FALSE) + geom_errorbar(position=position_dodge(.9), width=.25, aes(ymin=Conductancia, ymax=Conductancia+se)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) + scale_y_continuous(limits = c(0,55), breaks = seq(0, 55, 10)) + ylab(&quot;Conductancia&quot;) Luego podemos chequear algunos supuestos. spiderWide$diff &lt;- spiderWide$imagen - spiderWide$real # calcula la diferencia stat.desc(spiderWide$diff, basic = FALSE, norm = TRUE) # calcula los estadísticos ## median mean SE.mean CI.mean.0.95 var std.dev coef.var skewness ## -7.5000000 -7.0000000 2.8311043 6.2312185 96.1818182 9.8072330 -1.4010333 0.2464810 ## skew.2SE kurtosis kurt.2SE normtest.W normtest.p ## 0.1933785 -1.2342159 -0.5007991 0.9557903 0.7224801 Y luego haces el t-test. t_test2 &lt;- t.test(spiderWide$real, spiderWide$imagen, paired = TRUE) t_test2 ## ## Paired t-test ## ## data: spiderWide$real and spiderWide$imagen ## t = 2.4725, df = 11, p-value = 0.03098 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 0.7687815 13.2312185 ## sample estimates: ## mean of the differences ## 7 # Pero también lo podrías hacer si estuvieran en formato Long. t.test(Conductancia ~ Condicion, data=spiderLong, paired = TRUE) ## ## Paired t-test ## ## data: Conductancia by Condicion ## t = -2.4725, df = 11, p-value = 0.03098 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -13.2312185 -0.7687815 ## sample estimates: ## mean of the differences ## -7 Para terminar siempre es bueno calcular el tamaño del efecto. Podemos calcularlo de diferentes formas. t &lt;- t_test2$statistic[[1]] df &lt;- t_test2$parameter[[1]] (r &lt;- sqrt(t**2/(t**2+df))) ## [1] 0.5976869 r ## [1] 0.5976869 O podemos usar una función. # Cohen&#39;s d = (M2 - M1) / SDpooled # SDpooled = sqrt((SD1^2 + SD2^2)/ 2) cohen.d(spiderWide$real, spiderWide$imagen, paired = TRUE) ## ## Cohen&#39;s d ## ## d estimate: 0.6805173 (medium) ## 95 percent confidence interval: ## lower upper ## 0.04707723 1.31395743 "],["la-regresión.html", "Capítulo 7 La regresión 7.1 Modelos estadísticos 7.2 La ecuación de la recta 7.3 La suma de cuadrados 7.4 La regresión con R", " Capítulo 7 La regresión En este capítulo vamos a revisar el elemento básico para hacer modelos estadísticos: la regresión lineal. 7.1 Modelos estadísticos Revisa este video (17') y trata de responder: ¿Qué es un modelo estadístico? ¿Por qué es importante tener buenos modelos? ¿Cómo de determina el error en un modelo? ¿Qué son los grados de libertad? 7.2 La ecuación de la recta Revisa este video (8') y trata de responder: ¿Cómo se define la línea de la ecuación de un GLM que se ajuste mejor a los datos? ¿Cuál es el modelo más básico con el cual se compara un modelo que uno construya? 7.3 La suma de cuadrados Revisa este video (14') y trata de responder: ¿Qué es la SS total? ¿Qué es la SS de los residuales? ¿Qué es la SS del modelo? ¿Cómo se establece que un modelo dado explica mejor los datos que un modelo básico? ¿Cómo se establece cuan bueno es un modelo comparado con cuan malo es? ¿Lo que explica y lo que no explica un modelo? 7.4 La regresión con R Ahora vamos a hacer un análisis básico de regresión. Primero seteamos nuestro directorio de trabajo y cargamos las librerías que necesitemos (si no las tienes instaladas debes instalarlas). Luego importamos el set de datos y le damos una mirada. setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) library(ggplot2) library(car) Imagina que eres manager de un grupo musical y debes definir como invertir parte de tu presupuesto. A lo que aspiras en el fondo esa aumentar la venta de discos. Para ellos pirmero debes evaluar que factores afectan la venta de discos. Uno de estos factores es la cantidad de dineo invertido en la publicidad. En ese sentido, te gustaría saber cuál es la relación entre el dinero invertido en publicidad y el número de discos vendidos. album1 &lt;- read.csv(&quot;data/datos_ventas_de_discos_1.csv&quot;, header = TRUE) # load data head(album1) ## publicidad ventas ## 1 10.256 330 ## 2 985.685 120 ## 3 1445.563 360 ## 4 1188.193 270 ## 5 574.513 220 ## 6 568.954 170 Primero graficamos. ggplot(album1, aes(publicidad, ventas)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + labs(x=&quot;Cantidad de dinero gastado en publicidad&quot;, y=&quot;Ventas&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Lo que nos dice el sentido común, y lo que vemos en el gráfico efectivamente es que a mayor dinero invertido en publicidad debería haber mayores ventas. Es este un buen modelo para predecir el número de ventas a partir del dinero invertido en publicidad? Para analizar estos podemos hacer un modelo lineal con la función lm. En esta función usamos la típica relación entre resultado (ouctome) y variable explicativa (predictor), y le indicamos a R que base de datos usamos (datos): newModel &lt;- lm(outcome~predictor, datos) Luego podemos visualizar los resulatdos con la función summary. m_album &lt;- lm(ventas ~ publicidad, data = album1) summary(m_album) ## ## Call: ## lm(formula = ventas ~ publicidad, data = album1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -152.949 -43.796 -0.393 37.040 211.866 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.341e+02 7.537e+00 17.799 &lt;2e-16 *** ## publicidad 9.612e-02 9.632e-03 9.979 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 65.99 on 198 degrees of freedom ## Multiple R-squared: 0.3346, Adjusted R-squared: 0.3313 ## F-statistic: 99.59 on 1 and 198 DF, p-value: &lt; 2.2e-16 En qué debemos fijarnos dentro de los resultados que obtenemos al aplicar un módelo líneal? En la línea siguientes a &quot;Call&quot; aparece el módelo que usamos. También aparecen los llamados coeficientes que reflejan bajo el nombre de &quot;Estimate&quot; que refleja con que magnitud una variable predictora predice una variable resultado. Por ejemplo, por cada unidad de publicidad invertida el aumento en el número de ventas es 0.09. Y esta relación es significativa, o sea es diferente de 0 (lo que ocurre cuando no hay ninguna relación entre ambas variables). En el fondo este análisis nos dice que la publicidad si impacta sobre la venta de los discos. Sin embargo, a publicidad no es el único que podría afectar las ventas. En este sentido, podríamos estudiar otros factores que afectan esta variable resultados. Para ello hacemos lo que se llama una regresión múltiple. Primero cargamos los datos. album2 &lt;- read.csv(&quot;data/datos_ventas_de_discos_2.csv&quot;, header = TRUE) # load data head(album2) ## publicidad ventas radio eventos ## 1 10.256 330 43 10 ## 2 985.685 120 28 7 ## 3 1445.563 360 35 7 ## 4 1188.193 270 33 7 ## 5 574.513 220 44 5 ## 6 568.954 170 19 5 Podemos graficar la relación entre alguna variable de interés y el número de ventas. Por ejemplo, podríamos visualizar el impacto de la frecuencia de aparición de un tema musical en la radio. ggplot(album2, aes(publicidad, radio)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + labs(x=&quot;Número de apariciones en la radio&quot;, y=&quot;Ventas&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; Luego podríamos hacer un modelo para entender el impacto de distintos factores en la venta de discos. m_album2 &lt;- lm(ventas ~ publicidad + radio + eventos, data = album2) summary(m_album2) ## ## Call: ## lm(formula = ventas ~ publicidad + radio + eventos, data = album2) ## ## Residuals: ## Min 1Q Median 3Q Max ## -121.324 -28.336 -0.451 28.967 144.132 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -26.612958 17.350001 -1.534 0.127 ## publicidad 0.084885 0.006923 12.261 &lt; 2e-16 *** ## radio 3.367425 0.277771 12.123 &lt; 2e-16 *** ## eventos 11.086335 2.437849 4.548 9.49e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 47.09 on 196 degrees of freedom ## Multiple R-squared: 0.6647, Adjusted R-squared: 0.6595 ## F-statistic: 129.5 on 3 and 196 DF, p-value: &lt; 2.2e-16 ¿Qué conclusiones sacas de este análisis? "],["comparar-más-de-dos-grupos-anova.html", "Capítulo 8 Comparar más de dos grupos (ANOVA) 8.1 ¿Por qué necesitamos un ANOVA? 8.2 El ANOVA como un modelo líneal general 8.3 La lógica del ANOVA 8.4 El ANOVA con R", " Capítulo 8 Comparar más de dos grupos (ANOVA) En este capítulo vamos a revisar el típico análisis de varianza o ANOVA. 8.1 ¿Por qué necesitamos un ANOVA? Revisa este video (9') y trata de responder: ¿Cómo comparamos varias condiciones experimentales? ¿Cuántos distintos tipos de ANOVA existen? ¿De qué dependen del tipo de ANOVA que usemos para realizar un análisis? ¿Qué es un factor en un ANOVA? ¿Qué es un nivel en un ANOVA? ¿Qué es un ANOVA mixto? ¿En un experimento hipotético con 3 condiciones experimentales por qué no podemos usar 3 t-test? ¿Cuanto aumenta el error de tipo 1 cuando aumentamos el número de comparaciones que hacemos? ¿Qué es una prueba omnibus? ¿Cuáles son los supuestos del ANOVA? 8.2 El ANOVA como un modelo líneal general Revisa este video (18') y trata de responder: ¿Qué nos dice el valor F en un ANOVA? ¿Por qué el ANOVA se puede representar como una regresión? ¿Cómo se refleja un t-test en un modelo lineal general (GLM)? ¿Para que nos sirven las variables ficticias (dummy coding) en el ANOVA? ¿Qué refleja el intercepto de la ecuación que representa el ANOVA? ¿Qué reflejan los coeficientes (o betas) de la ecuación que representa el ANOVA? 8.3 La lógica del ANOVA Revisa este video (15') y trata de responder: ¿Qué reflejan los coeficientes (o betas) de la ecuación que representa el ANOVA? ¿Cómo serían los promedios de los grupos si la hipótesis nula se tuviera que aceptar? ¿Qué es la suma de cuadrados (SS) total? ¿Qué es la suma de cuadrados (SS) del modelo? ¿Qué es la suma de cuadrados (SS) de los residuales? 8.4 El ANOVA con R Ahora vamos a hacer el análisis. Primero seteamos nuestro directorio de trabajo y cargamos las librerías que necesitemos (si no las tienes instaladas debes instalarlas). Luego importamos el set de datos y le damos una mirada. setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) library(ggplot2) library(Hmisc) library(Rmisc) library(effsize) library(pastecs) library(reshape2) library(car) library(effsize) spiderLong &lt;- read.csv(&quot;data/ansiedad_por_arañas_indep.csv&quot;, header = TRUE) # load data spiderLong$Condicion &lt;- factor(spiderLong$Condicion) head(spiderLong) ## Sujeto Condicion Conductancia ## 1 1 imagen 30 ## 2 2 imagen 35 ## 3 3 imagen 45 ## 4 4 imagen 40 ## 5 5 imagen 50 ## 6 6 imagen 35 Luego, mirar los datos siempre es bueno graficar. # Podemos usar esta función para calcular los estadísticos a través de los participantes. datac &lt;- summarySE(spiderLong, measurevar=&quot;Conductancia&quot;, groupvars = &quot;Condicion&quot;) # Luego hacemos el gráfico ggplot(datac, aes(x = Condicion, y = Conductancia)) + geom_bar(position = position_dodge(width = 0.9), stat = &quot;identity&quot;, color = &quot;black&quot;, fill = &quot;White&quot;, show.legend=FALSE) + geom_errorbar(position=position_dodge(.9), width=.25, aes(ymin = Conductancia, ymax = Conductancia+se)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) + scale_y_continuous(limits = c(0,55), breaks = seq(0, 55, 10)) + ylab(&quot;Conductancia&quot;) Recordando lo que acabamos de aprender vamos a comparar los promedios por cada grupo con la información que resulta de aplicar una regresión lineal a estos datos. Primero describamos los datos. lapply(by(spiderLong$Conductancia, spiderLong$Condicion, stat.desc, basic = FALSE, norm = TRUE), round, 2) ## $imagen ## median mean SE.mean CI.mean.0.95 var std.dev coef.var skewness ## 40.00 40.00 2.68 5.90 86.36 9.29 0.23 0.00 ## skew.2SE kurtosis kurt.2SE normtest.W normtest.p ## 0.00 -1.39 -0.57 0.97 0.85 ## ## $real ## median mean SE.mean CI.mean.0.95 var std.dev coef.var skewness ## 50.00 47.00 3.18 7.01 121.64 11.03 0.23 -0.01 ## skew.2SE kurtosis kurt.2SE normtest.W normtest.p ## 0.00 -1.46 -0.59 0.95 0.62 La función by permite calcular los estadísticos. La función round redondea los valores a dos décimas. Y la función lapply permite aplicar la función round de forma másiva. Ahora, vamos a realiza una regresión lineal. Lo que queremos es predecir los valores de conductancia en función de los grupos (o condiciones) que tenemos. Para realizar la regresión usamos la función lm Luego de hacer la regresión lineal podemos revisar su contenido con la función summary. Recuerda mirar los coeficientes. ¿Qué ves? m1 &lt;- lm(Conductancia ~ Condicion, data=spiderLong) summary(m1) ## ## Call: ## lm(formula = Conductancia ~ Condicion, data = spiderLong) ## ## Residuals: ## Min 1Q Median 3Q Max ## -17.0 -8.5 1.5 8.0 18.0 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 40.000 2.944 13.587 3.53e-12 *** ## Condicionreal 7.000 4.163 1.681 0.107 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 10.2 on 22 degrees of freedom ## Multiple R-squared: 0.1139, Adjusted R-squared: 0.07359 ## F-statistic: 2.827 on 1 and 22 DF, p-value: 0.1068 Finalmente, podemos hacer el t-test. Pero, antes de hacerlo debemos verificar si existen problemas de homgeneidad de varianza. Podemos hacerlo con la función leveneTest leveneTest(spiderLong$Conductancia, spiderLong$Condicion) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 1 0.2991 0.59 ## 22 Luego podemos hacer el análisis estadístico, aplicando la función t.test. De la siguiente forma: newModel &lt;- t.test(outcome ~ predictor, data=df, var.equal = TRUE/FALSE, paired=TRUE/FALSE). Ya que no tenemos problemas de homogeneidad de varianzar seteamos var.equal a FALSE. t_test1 &lt;- t.test(Conductancia ~ Condicion, data=spiderLong, var.equal = TRUE, paired = FALSE) t_test1 ## ## Two Sample t-test ## ## data: Conductancia by Condicion ## t = -1.6813, df = 22, p-value = 0.1068 ## alternative hypothesis: true difference in means between group imagen and group real is not equal to 0 ## 95 percent confidence interval: ## -15.634222 1.634222 ## sample estimates: ## mean in group imagen mean in group real ## 40 47 Para terminar siempre es bueno calcular el tamaño del efecto. t &lt;- t_test1$statistic[[1]] df &lt;- t_test1$parameter[[1]] r &lt;- sqrt(t**2/(t**2+df)) r ## [1] 0.3374392 Ahora, imaginemos que en realidad nuestro diseño experimental era intra-sujetos. Vamos a usar exactamente los mismos datos que antes pero asumiendo un diseño intra-sujetos. Y asumiremos que estos datos viendo en un formato wide. spiderWide &lt;- read.csv(&quot;data/ansiedad_por_arañas_dep.csv&quot;, header = TRUE) # load data head (spiderWide) ## Sujeto imagen real ## 1 1 30 40 ## 2 2 35 35 ## 3 3 45 50 ## 4 4 40 55 ## 5 5 50 65 ## 6 6 35 55 Para realizar el gráfico para un diseño intra-sujetos tenemos que hacer algunos ajustes. spiderWideOri &lt;- spiderWide spiderWide$pMean &lt;- (spiderWide$imagen + spiderWide$real)/2 grandMean &lt;- mean(c(spiderWide$imagen, spiderWide$real)) spiderWide$adj &lt;- grandMean - spiderWide$pMean spiderWide$imagen_adj &lt;- spiderWide$imagen + spiderWide$adj spiderWide$real_adj &lt;- spiderWide$real + spiderWide$adj spiderWide$Mean2 &lt;- mean(spiderWide$imagen_adj + spiderWide$real_adj)/2 spiderWideSelec &lt;- spiderWide[, -c(2:5)] spiderWideSelec &lt;- spiderWideSelec[, -4] names(spiderWideSelec) &lt;- c(&quot;Sujeto&quot;, &quot;imagen&quot;, &quot;real&quot;) Los datos ajustados los transformamos a formato Long. adjustedData &lt;- melt(spiderWideSelec, id = c(&quot;Sujeto&quot;), measured = c(&quot;imagen&quot;, &quot;real&quot;)) names(adjustedData) &lt;- c(&quot;Sujeto&quot;, &quot;Condicion&quot;, &quot;Conductancia&quot;) Luego procedemos como antes. # Podemos usar esta función para calcular los estadísticos para un diseño intra-sujetos. datac2 &lt;- summarySEwithin(adjustedData, measurevar=&quot;Conductancia&quot;, withinvars=&quot;Condicion&quot;, idvar=&quot;Sujeto&quot;) ggplot(datac2, aes(x=Condicion, y=Conductancia)) + geom_bar(position = position_dodge(width = 0.9), stat=&quot;identity&quot;, color=&quot;black&quot;, fill=&quot;White&quot;, show.legend=FALSE) + geom_errorbar(position=position_dodge(.9), width=.25, aes(ymin=Conductancia, ymax=Conductancia+se)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = &quot;black&quot;)) + scale_y_continuous(limits = c(0,55), breaks = seq(0, 55, 10)) + ylab(&quot;Conductancia&quot;) Luego podemos chequear algunos supuestos. spiderWide$diff &lt;- spiderWide$imagen - spiderWide$real # calcula la diferencia stat.desc(spiderWide$diff, basic = FALSE, norm = TRUE) # calcula los estadísticos ## median mean SE.mean CI.mean.0.95 var std.dev coef.var skewness ## -7.5000000 -7.0000000 2.8311043 6.2312185 96.1818182 9.8072330 -1.4010333 0.2464810 ## skew.2SE kurtosis kurt.2SE normtest.W normtest.p ## 0.1933785 -1.2342159 -0.5007991 0.9557903 0.7224801 Y luego haces el t-test. t_test2 &lt;- t.test(spiderWide$real, spiderWide$imagen, paired = TRUE) t_test2 ## ## Paired t-test ## ## data: spiderWide$real and spiderWide$imagen ## t = 2.4725, df = 11, p-value = 0.03098 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 0.7687815 13.2312185 ## sample estimates: ## mean of the differences ## 7 # Pero también lo podrías hacer si estuvieran en formato Long. t.test(Conductancia ~ Condicion, data=spiderLong, paired = TRUE) ## ## Paired t-test ## ## data: Conductancia by Condicion ## t = -2.4725, df = 11, p-value = 0.03098 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -13.2312185 -0.7687815 ## sample estimates: ## mean of the differences ## -7 Para terminar siempre es bueno calcular el tamaño del efecto. Podemos calcularlo de diferentes formas. t &lt;- t_test2$statistic[[1]] df &lt;- t_test2$parameter[[1]] (r &lt;- sqrt(t**2/(t**2+df))) ## [1] 0.5976869 r ## [1] 0.5976869 O podemos usar una función. # Cohen&#39;s d = (M2 - M1) / SDpooled # SDpooled = sqrt((SD1^2 + SD2^2)/ 2) cohen.d(spiderWide$real, spiderWide$imagen, paired = TRUE) ## ## Cohen&#39;s d ## ## d estimate: 0.6805173 (medium) ## 95 percent confidence interval: ## lower upper ## 0.04707723 1.31395743 "],["otros-análisis.html", "Capítulo 9 Otros análisis 9.1 Análisis de proporciones", " Capítulo 9 Otros análisis En este capítulo vamos a revisar otros análisis estadísticos. 9.1 Análisis de proporciones Imagina que estás analizando una base de datos dónde los participantes tenían que elegir entre dos tipos de chocolates. Primero seteamos nuestro directorio de trabajo y graficar los datos. Cargamos la librería ggplot2 y otras librerías que nos serviran. Si no tienes estas librerías debes instalarlas. Luego importamos nuestro set de datos y lo miramos. setwd(&quot;C:/Users/Usuario/Documents/JoseLuis/UTalca_2018/Estadistica_Bookdown/estadistica&quot;) prefsAB &lt;- read.csv(&quot;data/prefsAB.csv&quot;) prefsAB$Participante &lt;- factor(prefsAB$Participante) # convertimos Participante a factor prefsAB$Preferencia &lt;- factor(prefsAB$Preferencia) # convertimos Preferencia a factor head(prefsAB) ## Participante Preferencia ## 1 1 Sahne-Nuss ## 2 2 Sahne-Nuss ## 3 3 Sahne-Nuss ## 4 4 Sahne-Nuss ## 5 5 Sahne-Nuss ## 6 6 Sahne-Nuss Luego realizamos un gráfico para visualizar diferencias en las preferencias. library(ggplot2) ggplot(prefsAB, aes(Preferencia, ..count..)) + geom_bar(aes(fill = Preferencia), position = &quot;dodge&quot;) + ylab(&quot;Número de personas&quot;) Podemos usar la función xtabs para obtener una tabla de contigencia. Luego con la función chisq.test cálculamos la probabilidad que estas dos preferencias esten igualmente distribuidas (una prueba clásica de chi cuadrado). (tabla.contingencia &lt;- xtabs( ~ Preferencia, prefsAB)) ## Preferencia ## Sahne-Nuss Trencito ## 46 14 chisq.test(tabla.contingencia) ## ## Chi-squared test for given probabilities ## ## data: tabla.contingencia ## X-squared = 17.067, df = 1, p-value = 3.609e-05 Otro test parecido, pero mas exacto es un test binomial. binom.test(tabla.contingencia) ## ## Exact binomial test ## ## data: tabla.contingencia ## number of successes = 46, number of trials = 60, p-value = 4.224e-05 ## alternative hypothesis: true probability of success is not equal to 0.5 ## 95 percent confidence interval: ## 0.6396172 0.8661627 ## sample estimates: ## probability of success ## 0.7666667 Ahora imagina que estás analizando una base de datos dónde los participantes tenían que elegir entre 3 tipos de chocolates. Nuevamente, importamos primero nuestro set de datos. prefsABC &lt;- read.csv(&quot;data/prefsABC.csv&quot;) prefsABC$Participante &lt;- factor(prefsABC$Participante) # convertimos Participante a factor prefsABC$Preferencia &lt;- factor(prefsABC$Preferencia) # convertimos Preferencia a factor head(prefsABC) ## Participante Preferencia ## 1 1 Golden-Nuss ## 2 2 Golden-Nuss ## 3 3 Sahne-Nuss ## 4 4 Golden-Nuss ## 5 5 Golden-Nuss ## 6 6 Sahne-Nuss Realizamos el gráfico para visualizar diferencias en las preferencias. library(ggplot2) ggplot(prefsABC, aes(Preferencia, ..count..)) + geom_bar(aes(fill = Preferencia), position = &quot;dodge&quot;) + ylab(&quot;Número de personas&quot;) Podemos usar la función xtabs para obtener una tabla de contigencia. Luego con la función chisq.test cálculamos la probabilidad que estas dos preferencias esten igualmente distribuidas (una prueba clásica de chi cuadrado). (tabla.contingencia &lt;- xtabs( ~ Preferencia, prefsABC)) ## Preferencia ## Golden-Nuss Sahne-Nuss Trencito ## 31 21 8 chisq.test(tabla.contingencia) ## ## Chi-squared test for given probabilities ## ## data: tabla.contingencia ## X-squared = 13.3, df = 2, p-value = 0.001294 Otro test parecido, pero mas exacto es un test multinomial. library(XNomial) xmulti(tabla.contingencia, c(1/3, 1/3, 1/3), statName = &quot;Prob&quot;) ## ## P value (Prob) = 0.0008024 Luego que pesquisamos diferencias generales podemos hacer comparaciones más específicas entre pares de elementos. Podemos usar la función p.adjust para ajustar el valor de p para tener en cuenta el problema de comparaciones múltiples. PrefA &lt;- binom.test(sum(prefsABC$Preferencia == &quot;Trencito&quot;), nrow(prefsABC), p=1/3) PrefB &lt;- binom.test(sum(prefsABC$Preferencia == &quot;Sahne-Nuss&quot;), nrow(prefsABC), p=1/3) PrefC &lt;- binom.test(sum(prefsABC$Preferencia == &quot;Golden-Nuss&quot;), nrow(prefsABC), p=1/3) p.adjust(c(PrefA$p.value, PrefB$p.value, PrefC$p.value), method=&quot;holm&quot;) ## [1] 0.001659954 0.785201685 0.007446980 En un siguiente nivel de complejidad imagina que ahora estás analizando una base de datos dónde los participantes tenían que elegir entre 2 tipos de chocolates, pero además se registró si era un hombre o una mujer. Nuevamente, importamos primero nuestro set de datos. prefsABsex &lt;- read.csv(&quot;data/prefsABsex.csv&quot;) prefsABsex$Participante &lt;- factor(prefsABsex$Participante) # convertimos a factor prefsABsex$Preferencia &lt;- factor(prefsABsex$Preferencia) # convertimos a factor prefsABsex$Genero &lt;- factor(prefsABsex$Genero) # convertimos a factor head(prefsABsex) ## Participante Preferencia Genero ## 1 1 Sahne-Nuss Femenino ## 2 2 Sahne-Nuss Femenino ## 3 3 Sahne-Nuss Femenino ## 4 4 Sahne-Nuss Masculino ## 5 5 Sahne-Nuss Femenino ## 6 6 Sahne-Nuss Masculino Realizamos el gráfico para visualizar diferencias en las preferencias. library(ggplot2) ggplot(prefsABsex, aes(Preferencia, ..count..)) + geom_bar(aes(fill = Preferencia), position = &quot;dodge&quot;) + facet_wrap( ~ Genero) + ylab(&quot;Número de personas&quot;) Podemos usar la función xtabs para obtener una tabla de contigencia. Luego con la función chisq.test cálculamos la probabilidad que estas dos preferencias en función del género esten igualmente distribuidas. (tabla.contingencia &lt;- xtabs( ~ Preferencia + Genero, prefsABsex)) ## Genero ## Preferencia Femenino Masculino ## Sahne-Nuss 29 17 ## Trencito 2 12 chisq.test(tabla.contingencia) ## ## Pearson&#39;s Chi-squared test with Yates&#39; continuity correction ## ## data: tabla.contingencia ## X-squared = 8.3588, df = 1, p-value = 0.003838 Otro test parecido, pero mas exacto es un test de Fisher fisher.test(tabla.contingencia) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: tabla.contingencia ## p-value = 0.001877 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 1.862023 101.026914 ## sample estimates: ## odds ratio ## 9.844814 Finalmente, imagina que ahora estás analizando una base de datos dónde los participantes tenían que elegir entre 3 tipos de chocolates, pero además se registró si era un hombre o una mujer. Nuevamente, importamos primero nuestro set de datos. prefsABCsex &lt;- read.csv(&quot;data/prefsABCsex.csv&quot;) prefsABCsex$Participante &lt;- factor(prefsABCsex$Participante) # convertimos a factor prefsABCsex$Preferencia &lt;- factor(prefsABCsex$Preferencia) # convertimos a factor prefsABCsex$Genero &lt;- factor(prefsABCsex$Genero) # convertimos a factor head(prefsABCsex) ## Participante Preferencia Genero ## 1 1 Golden-Nuss Femenino ## 2 2 Golden-Nuss Masculino ## 3 3 Sahne-Nuss Masculino ## 4 4 Golden-Nuss Masculino ## 5 5 Golden-Nuss Masculino ## 6 6 Sahne-Nuss Femenino Realizamos el gráfico para visualizar diferencias en las preferencias. library(ggplot2) ggplot(prefsABCsex, aes(Preferencia, ..count..)) + geom_bar(aes(fill = Preferencia), position = &quot;dodge&quot;) + facet_wrap( ~ Genero) + ylab(&quot;Número de personas&quot;) Podemos usar la función xtabs para obtener una tabla de contigencia. Luego con la función chisq.test cálculamos la probabilidad que estas dos preferencias en función del género esten igualmente distribuidas. (tabla.contingencia &lt;- xtabs( ~ Preferencia + Genero, prefsABCsex)) ## Genero ## Preferencia Femenino Masculino ## Golden-Nuss 11 20 ## Sahne-Nuss 15 6 ## Trencito 3 5 chisq.test(tabla.contingencia) ## Warning in chisq.test(tabla.contingencia): Chi-squared approximation may be incorrect ## ## Pearson&#39;s Chi-squared test ## ## data: tabla.contingencia ## X-squared = 6.9111, df = 2, p-value = 0.03157 Otro test parecido, pero mas exacto es un test de Fisher fisher.test(tabla.contingencia) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: tabla.contingencia ## p-value = 0.03261 ## alternative hypothesis: two.sided Luego que pesquisamos diferencias generales podemos hacer comparaciones más específicas entre pares de elementos. Primero, podemos hacer test binomiales sólo para los hombres. Hay diferencias significativas entre las preferencias de los hombres? male_A &lt;- binom.test(sum(prefsABCsex[prefsABCsex$Genero == &quot;Masculino&quot;,]$Preferencia == &quot;Trencito&quot;), nrow(prefsABCsex[prefsABCsex$Genero == &quot;Masculino&quot;,]), p=1/3) male_B &lt;- binom.test(sum(prefsABCsex[prefsABCsex$Genero == &quot;Masculino&quot;,]$Preferencia == &quot;Sahne-Nuss&quot;), nrow(prefsABCsex[prefsABCsex$Genero == &quot;Masculino&quot;,]), p=1/3) male_C &lt;- binom.test(sum(prefsABCsex[prefsABCsex$Genero == &quot;Masculino&quot;,]$Preferencia == &quot;Golden-Nuss&quot;), nrow(prefsABCsex[prefsABCsex$Genero == &quot;Masculino&quot;,]), p=1/3) pvalues &lt;- p.adjust(c(male_A$p.value, male_B$p.value, male_C$p.value), method=&quot;holm&quot;) formatC(pvalues, format = &quot;f&quot;, digits = 6) ## [1] &quot;0.109474&quot; &quot;0.126622&quot; &quot;0.001297&quot; Segundo, podemos hacer test binomiales sólo para las mujeres. Hay diferencias significativas entre las preferencias de las mujeres? female_A &lt;- binom.test(sum(prefsABCsex[prefsABCsex$Genero == &quot;Femenino&quot;,]$Preferencia == &quot;Trencito&quot;), nrow(prefsABCsex[prefsABCsex$Genero == &quot;Femenino&quot;,]), p=1/3) female_B &lt;- binom.test(sum(prefsABCsex[prefsABCsex$Genero == &quot;Femenino&quot;,]$Preferencia == &quot;Sahne-Nuss&quot;), nrow(prefsABCsex[prefsABCsex$Genero == &quot;Femenino&quot;,]), p=1/3) female_C &lt;- binom.test(sum(prefsABCsex[prefsABCsex$Genero == &quot;Femenino&quot;,]$Preferencia == &quot;Golden-Nuss&quot;), nrow(prefsABCsex[prefsABCsex$Genero == &quot;Femenino&quot;,]), p=1/3) pvalues &lt;- p.adjust(c(female_A$p.value, female_B$p.value, female_C$p.value), method=&quot;holm&quot;) formatC(pvalues, format = &quot;f&quot;, digits = 6) ## [1] &quot;0.027033&quot; &quot;0.094478&quot; &quot;0.693970&quot; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
